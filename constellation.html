<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation â€¢ Squad Pluto</title>
    <style>
        :root { --accent: #9ec2ff; --glow: rgba(160, 195, 255, 0.30); --radial-x: 50%; --radial-y: 45%; }
        #bg { position: fixed; inset: 0; z-index: 0; pointer-events: none; display: block; }
        html, body { margin: 0; padding: 0; height: 100dvh; overflow: hidden; overscroll-behavior: none; background: radial-gradient(900px 600px at var(--radial-x) var(--radial-y), rgba(60, 70, 120, 0.18), rgba(0,0,0,0)), #020205; color: rgba(230, 235, 255, 0.9); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .ui { position: fixed; top: 12px; left: 12px; z-index: 2; display: flex; gap: 10px; align-items: center; }
        .legend { display: inline-flex; gap: 8px; align-items: center; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .dot.theme { background: rgba(150, 200, 255, 0.9); box-shadow: 0 0 14px rgba(150, 200, 255, 0.35); }
        .dot.project { background: rgba(200, 220, 255, 0.85); box-shadow: 0 0 10px rgba(200, 220, 255, 0.25); }
        .sep { width: 1px; height: 16px; background: rgba(170, 200, 255, 0.28); margin: 0 4px; }
        .btn { appearance: none; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); color: rgba(230, 235, 255, 0.92); padding: 8px 10px; border-radius: 10px; font-size: 12px; letter-spacing: 0.2px; text-decoration: none; cursor: pointer; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .btn:hover { border-color: rgba(200, 220, 255, 0.5); }
        .tooltip { position: fixed; z-index: 3; transform: translate(-50%, -120%); pointer-events: none; padding: 6px 8px; border-radius: 8px; font-size: 12px; color: rgba(235, 240, 255, 0.96); background: rgba(12, 14, 24, 0.85); border: 1px solid rgba(170, 200, 255, 0.28); display: none; }
        @media (prefers-reduced-motion: reduce) { .btn { transition: none; } }
    </style>
    <meta name="description" content="Interactive constellation map of Squad Pluto projects and themes." />
</head>
<body>
    <canvas id="bg"></canvas>
    <div class="ui">
        <div class="legend" aria-label="Legend">
            <span class="dot theme"></span><span>Theme</span>
            <span class="sep"></span>
            <span class="dot project"></span><span>Project</span>
        </div>
        <a class="btn" href="./index.html">Back to Home</a>
    </div>
    <div class="tooltip" id="tooltip" role="status" aria-live="polite"></div>
    <script>
    'use strict';
    // DPR setup
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
        const w = Math.floor(window.innerWidth);
        const h = Math.floor(window.innerHeight);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Colors
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#9ec2ff';
    function hexToRgb(hex) {
        const m = hex.replace('#', '');
        const int = parseInt(m, 16);
        if (m.length === 6 && !Number.isNaN(int)) { return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 }; }
        return { r: 158, g: 194, b: 255 };
    }
    const { r, g, b } = hexToRgb(accent);
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Seeded RNG for deterministic layout
    function mulberry32(a) { return function() { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    const rand = mulberry32(0xC0FFEE);

    // Data model
    const themes = [
        { id: 't-data', label: 'Data & AI' },
        { id: 't-automation', label: 'Automation' },
        { id: 't-vision', label: 'Vision' },
        { id: 't-forecasting', label: 'Forecasting' },
        { id: 't-knowledge', label: 'Knowledge' }
    ];
    const projects = [
        { id: 'p-sentinel', label: 'Sentinel', href: './sentinel.html', themes: ['t-data', 't-automation'] },
        { id: 'p-spp', label: 'Session Params Prediction', href: './session-params-prediction.html', themes: ['t-forecasting', 't-data'] },
        { id: 'p-crowdflex', label: 'Crowdflex', href: './crowdflex.html', themes: ['t-forecasting', 't-automation'] },
        { id: 'p-jcv', label: 'Journey Computer Vision', href: './journey-computer-vision.html', themes: ['t-vision', 't-automation'] },
        { id: 'p-csa', label: 'Customer Success Agents', href: './customer-success-agents.html', themes: ['t-automation', 't-knowledge'] },
        { id: 'p-cx-eval', label: 'CX Agents Evaluation', href: './cx-agents-evaluation.html', themes: ['t-automation', 't-data'] },
        { id: 'p-cx-engine', label: 'CX Engine', href: './cx-engine.html', themes: ['t-automation'] },
        { id: 'p-ecf', label: 'Energy Consumption Forecasting', href: './energy-consumption-forecasting.html', themes: ['t-forecasting', 't-data'] },
        { id: 'p-ml-aiops', label: 'ML/AIOps', href: './ml-aiops.html', themes: ['t-data'] },
        { id: 'p-knowledge', label: 'Ohme Enterprise Knowledge Center', href: './ohme-enterprise-knowledge-center.html', themes: ['t-knowledge'] },
        { id: 'p-pocs', label: 'POCs / Explorations', href: './pocs.html', themes: ['t-data', 't-vision', 't-forecasting', 't-automation'] }
    ];

    const nodes = [];
    const edges = [];
    const W = () => canvas.width / dpr, H = () => canvas.height / dpr;

    // Initialize node positions in a ring for stability
    function init() {
        nodes.length = 0; edges.length = 0;
        const cx = W() / 2, cy = H() / 2;
        const themeRadius = Math.min(cx, cy) * 0.45;
        const projRadius = Math.min(cx, cy) * 0.25;
        themes.forEach((t, i) => {
            const a = (i / themes.length) * Math.PI * 2;
            nodes.push({ id: t.id, label: t.label, type: 'theme', x: cx + Math.cos(a) * themeRadius, y: cy + Math.sin(a) * themeRadius, vx: 0, vy: 0, r: 12, fixed: false });
        });
        projects.forEach((p, i) => {
            const a = (i / projects.length) * Math.PI * 2 + 0.2;
            nodes.push({ id: p.id, label: p.label, type: 'project', href: p.href, x: cx + Math.cos(a) * projRadius, y: cy + Math.sin(a) * projRadius, vx: 0, vy: 0, r: 7, fixed: false });
            p.themes.forEach(tid => edges.push({ a: p.id, b: tid }));
        });
    }
    init();

    function getNode(id) { return nodes.find(n => n.id === id); }

    // Physics parameters
    const REPULSE = 2500;   // Coulomb-like constant
    const SPRING = 0.02;    // Hooke spring
    const DAMPING = 0.9;    // velocity damping
    const CENTER = 0.02;    // pull to center
    const REST = 90;        // desired edge length

    // Pan/Zoom state
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isPanning = false;
    let panStartX = 0, panStartY = 0, startOffsetX = 0, startOffsetY = 0;

    function worldToScreen(x, y) { return { x: (x * scale) + offsetX, y: (y * scale) + offsetY }; }
    function screenToWorld(x, y) { return { x: (x - offsetX) / scale, y: (y - offsetY) / scale }; }

    canvas.addEventListener('pointerdown', (e) => {
        isPanning = true; panStartX = e.clientX; panStartY = e.clientY; startOffsetX = offsetX; startOffsetY = offsetY; canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointermove', (e) => {
        if (isPanning) { offsetX = startOffsetX + (e.clientX - panStartX); offsetY = startOffsetY + (e.clientY - panStartY); }
    }, { passive: true });
    canvas.addEventListener('pointerup', (e) => { isPanning = false; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointercancel', () => { isPanning = false; });
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY;
        const zoom = Math.exp(delta * 0.001);
        const mouseX = e.clientX, mouseY = e.clientY;
        const before = screenToWorld(mouseX, mouseY);
        scale = Math.min(2.0, Math.max(0.5, scale * zoom));
        const after = screenToWorld(mouseX, mouseY);
        offsetX += (before.x - after.x) * scale;
        offsetY += (before.y - after.y) * scale;
    }, { passive: false });

    // Hover / click
    const tooltip = document.getElementById('tooltip');
    let hoverId = null;
    function updateHover(mx, my) {
        const { x: wx, y: wy } = screenToWorld(mx, my);
        let best = null, bestD = Infinity;
        for (const n of nodes) {
            const dx = n.x - wx, dy = n.y - wy;
            const d2 = dx*dx + dy*dy;
            const rr = (n.r + 8) * (n.r + 8);
            if (d2 < rr && d2 < bestD) { best = n; bestD = d2; }
        }
        hoverId = best ? best.id : null;
        if (hoverId) {
            tooltip.textContent = best.label;
            tooltip.style.left = mx + 'px';
            tooltip.style.top = my + 'px';
            tooltip.style.display = 'block';
        } else {
            tooltip.style.display = 'none';
        }
    }
    window.addEventListener('pointermove', (e) => { updateHover(e.clientX, e.clientY); }, { passive: true });
    window.addEventListener('click', (e) => {
        if (!hoverId) return;
        const n = getNode(hoverId);
        if (n && n.href) {
            window.location.href = n.href;
        }
    });

    // Simulation tick
    function tick() {
        const cx = W() / 2, cy = H() / 2;
        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
            const a = nodes[i];
            if (!prefersReducedMotion) {
                const gx = (cx - a.x) * CENTER; // center pull
                const gy = (cy - a.y) * CENTER;
                a.vx += gx; a.vy += gy;
            }
            for (let j = i + 1; j < nodes.length; j++) {
                const b = nodes[j];
                let dx = a.x - b.x, dy = a.y - b.y;
                let d2 = dx*dx + dy*dy + 0.01;
                const f = REPULSE / d2;
                const fx = f * dx, fy = f * dy;
                a.vx += fx; a.vy += fy;
                b.vx -= fx; b.vy -= fy;
            }
        }
        // Springs
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            let dx = B.x - A.x, dy = B.y - A.y;
            const d = Math.max(0.001, Math.sqrt(dx*dx + dy*dy));
            const k = SPRING;
            const target = REST * (A.type === 'theme' || B.type === 'theme' ? 1.0 : 0.9);
            const diff = (d - target);
            const fx = (dx / d) * diff * k;
            const fy = (dy / d) * diff * k;
            A.vx += fx; A.vy += fy;
            B.vx -= fx; B.vy -= fy;
        }
        // Integrate
        for (const n of nodes) {
            if (prefersReducedMotion) continue; // static layout
            n.vx *= DAMPING; n.vy *= DAMPING;
            n.x += n.vx * 0.02; n.y += n.vy * 0.02;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // world transform
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        // edges
        ctx.lineWidth = 1;
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            const alpha = (hoverId && (hoverId === A.id || hoverId === B.id)) ? 0.16 : 0.08;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            ctx.beginPath();
            // subtle curve: control point at mid plus slight normal offset
            const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
            const nx = (B.y - A.y), ny = -(B.x - A.x);
            const norm = Math.hypot(nx, ny) || 1;
            const off = 10;
            const cpx = mx + (nx / norm) * off; const cpy = my + (ny / norm) * off;
            ctx.moveTo(A.x, A.y);
            ctx.quadraticCurveTo(cpx, cpy, B.x, B.y);
            ctx.stroke();
        }
        // nodes
        for (const n of nodes) {
            const isHover = hoverId === n.id;
            const rr = n.r;
            // glow
            if (n.type === 'theme') {
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.35 : 0.22})`;
                ctx.beginPath(); ctx.arc(n.x, n.y, rr + 6, 0, Math.PI * 2); ctx.fill();
            } else {
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.28 : 0.16})`;
                ctx.beginPath(); ctx.arc(n.x, n.y, rr + 4, 0, Math.PI * 2); ctx.fill();
            }
            // core
            ctx.fillStyle = 'rgba(10, 12, 20, 0.9)';
            ctx.beginPath(); ctx.arc(n.x, n.y, rr, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.9 : 0.55})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            // label (always readable, centered)
            ctx.fillStyle = 'rgba(220, 230, 255, 0.9)';
            ctx.font = `${n.type === 'theme' ? 12 : 11}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const label = n.label;
            ctx.fillText(label, n.x, n.y + rr + 6);
        }
        ctx.restore();
    }

    function loop() {
        if (!prefersReducedMotion) tick();
        draw();
        requestAnimationFrame(loop);
    }
    // For reduced motion, pre-settle the layout with a few steps
    if (prefersReducedMotion) {
        for (let i = 0; i < 300; i++) tick();
        draw();
    }
    loop();
    </script>
</body>
</html>


