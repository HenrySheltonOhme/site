<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation â€¢ Squad Pluto</title>
    <style>
        :root { --accent: #9ec2ff; --glow: rgba(160, 195, 255, 0.30); --radial-x: 50%; --radial-y: 45%; }
        #bg { position: fixed; inset: 0; z-index: 0; pointer-events: auto; display: block; }
        html, body { margin: 0; padding: 0; height: 100dvh; overflow: hidden; overscroll-behavior: none; background: radial-gradient(900px 600px at var(--radial-x) var(--radial-y), rgba(60, 70, 120, 0.18), rgba(0,0,0,0)), #020205; color: rgba(230, 235, 255, 0.9); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .ui { position: fixed; top: 12px; left: 12px; z-index: 2; display: flex; gap: 10px; align-items: center; }
        .legend { display: inline-flex; gap: 8px; align-items: center; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .legend-chip { display: inline-flex; gap: 8px; align-items: center; padding: 6px 8px; border-radius: 999px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.4); color: rgba(230, 235, 255, 0.92); cursor: pointer; }
        .legend-chip:hover { border-color: rgba(200, 220, 255, 0.5); }
        .legend-chip.off { opacity: 0.55; border-color: rgba(170, 200, 255, 0.18); }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .dot.theme { background: rgba(150, 200, 255, 0.9); box-shadow: 0 0 14px rgba(150, 200, 255, 0.35); }
        .dot.project { background: rgba(200, 220, 255, 0.85); box-shadow: 0 0 10px rgba(200, 220, 255, 0.25); }
        .sep { width: 1px; height: 16px; background: rgba(170, 200, 255, 0.28); margin: 0 4px; }
        .btn { appearance: none; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); color: rgba(230, 235, 255, 0.92); padding: 8px 10px; border-radius: 10px; font-size: 12px; letter-spacing: 0.2px; text-decoration: none; cursor: pointer; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .btn:hover { border-color: rgba(200, 220, 255, 0.5); }
        .tooltip { position: fixed; z-index: 3; transform: translate(-50%, -120%); pointer-events: none; padding: 6px 8px; border-radius: 8px; font-size: 12px; color: rgba(235, 240, 255, 0.96); background: rgba(12, 14, 24, 0.85); border: 1px solid rgba(170, 200, 255, 0.28); display: none; }
        /* Controls panel (top-right) */
        .panel { position: fixed; top: 12px; right: 12px; z-index: 2; width: 260px; padding: 10px; border-radius: 12px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); color: rgba(230,235,255,0.92); }
        .panel h3 { margin: 0 0 8px; font-size: 13px; font-weight: 600; letter-spacing: .3px; color: rgba(210, 220, 255, 0.9); }
        .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 8px 0; }
        .row label { font-size: 12px; color: rgba(200, 210, 245, 0.9); }
        .row input[type="range"] { width: 140px; }
        .toggle { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .panel .actions { display: flex; gap: 6px; margin-top: 8px; }
        .panel .btn { padding: 6px 8px; font-size: 12px; }
        @media (prefers-reduced-motion: reduce) { .btn { transition: none; } }
    </style>
    <meta name="description" content="Interactive constellation map of Squad Pluto projects and themes." />
</head>
<body>
    <canvas id="bg"></canvas>
    <div class="ui">
        <div class="legend" aria-label="Legend">
            <button class="legend-chip" id="toggle-themes" aria-pressed="true" title="Toggle themes"><span class="dot theme"></span><span>Theme</span></button>
            <span class="sep"></span>
            <button class="legend-chip" id="toggle-projects" aria-pressed="true" title="Toggle projects"><span class="dot project"></span><span>Project</span></button>
        </div>
        <a class="btn" href="./index.html">Back to Home</a>
    </div>
    <div class="tooltip" id="tooltip" role="status" aria-live="polite"></div>
    <div class="panel" id="panel" aria-label="Controls">
        <h3>Constellation Controls</h3>
        <div class="row"><label for="repulse">Repulsion</label><input id="repulse" type="range" min="500" max="6000" step="100" value="1050"></div>
        <div class="row"><label for="spring">Spring</label><input id="spring" type="range" min="1" max="80" step="1" value="80"></div>
        <div class="row"><label for="rest">Rest length</label><input id="rest" type="range" min="40" max="160" step="2" value="90"></div>
        <div class="toggle"><input id="contain" type="checkbox"><label for="contain">Contain nodes in view</label></div>
        <div class="actions">
            <button class="btn" id="recenter">Recenter</button>
            <button class="btn" id="reset">Reset Layout</button>
            <button class="btn" id="unpin">Unpin All</button>
        </div>
    </div>
    <script>
    'use strict';
    // DPR setup
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
        const w = Math.floor(window.innerWidth);
        const h = Math.floor(window.innerHeight);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Colors
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#9ec2ff';
    function hexToRgb(hex) {
        const m = hex.replace('#', '');
        const int = parseInt(m, 16);
        if (m.length === 6 && !Number.isNaN(int)) { return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 }; }
        return { r: 158, g: 194, b: 255 };
    }
    const { r, g, b } = hexToRgb(accent);
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Seeded RNG for deterministic layout
    function mulberry32(a) { return function() { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    const rand = mulberry32(0xC0FFEE);

    // Data model
    const themes = [
        { id: 't-data', label: 'Data & AI' },
        { id: 't-automation', label: 'Automation' },
        { id: 't-vision', label: 'Vision' },
        { id: 't-forecasting', label: 'Forecasting' },
        { id: 't-knowledge', label: 'Knowledge' }
    ];
    const projects = [
        { id: 'p-sentinel', label: 'Sentinel', href: './sentinel.html', themes: ['t-data', 't-automation'], active: true },
        { id: 'p-spp', label: 'Session Params Prediction', href: './session-params-prediction.html', themes: ['t-forecasting', 't-data'], active: true },
        { id: 'p-crowdflex', label: 'Crowdflex', href: './crowdflex.html', themes: ['t-forecasting', 't-automation'], active: true },
        { id: 'p-jcv', label: 'Journey Computer Vision', href: './journey-computer-vision.html', themes: ['t-vision', 't-automation'], active: true },
        { id: 'p-csa', label: 'Customer Success Agents', href: './customer-success-agents.html', themes: ['t-automation', 't-knowledge'], active: true },
        { id: 'p-cx-eval', label: 'CX Agents Evaluation', href: './cx-agents-evaluation.html', themes: ['t-automation', 't-data'], active: false },
        { id: 'p-cx-engine', label: 'CX Engine', href: './cx-engine.html', themes: ['t-automation'], active: false },
        { id: 'p-ecf', label: 'Energy Consumption Forecasting', href: './energy-consumption-forecasting.html', themes: ['t-forecasting', 't-data'], active: true },
        { id: 'p-ml-aiops', label: 'ML/AIOps', href: './ml-aiops.html', themes: ['t-data'], active: false },
        { id: 'p-knowledge', label: 'Ohme Enterprise Knowledge Center', href: './ohme-enterprise-knowledge-center.html', themes: ['t-knowledge'], active: false },
        { id: 'p-pocs', label: 'POCs / Explorations', href: './pocs.html', themes: ['t-data', 't-vision', 't-forecasting', 't-automation'], active: true }
    ];

    const nodes = [];
    const edges = [];
    const W = () => canvas.width / dpr, H = () => canvas.height / dpr;

    // Initialize node positions in a ring for stability
    function init() {
        nodes.length = 0; edges.length = 0;
        const cx = W() / 2, cy = H() / 2;
        const themeRadius = Math.min(cx, cy) * 0.45;
        const projRadius = Math.min(cx, cy) * 0.25;
        themes.forEach((t, i) => {
            const a = (i / themes.length) * Math.PI * 2;
            nodes.push({ id: t.id, label: t.label, type: 'theme', x: cx + Math.cos(a) * themeRadius, y: cy + Math.sin(a) * themeRadius, vx: 0, vy: 0, r: 12, fixed: false });
        });
        projects.forEach((p, i) => {
            const a = (i / projects.length) * Math.PI * 2 + 0.2;
            nodes.push({ id: p.id, label: p.label, type: 'project', href: p.href, x: cx + Math.cos(a) * projRadius, y: cy + Math.sin(a) * projRadius, vx: 0, vy: 0, r: 7, fixed: false });
            p.themes.forEach(tid => edges.push({ a: p.id, b: tid }));
        });
    }
    init();

    function getNode(id) { return nodes.find(n => n.id === id); }

    // Physics parameters
    let PARAMS = {
        repulse: 1050,
        spring: 0.8,
        damping: 0.9,
        center: 0.02,
        rest: 90,
        contain: false
    };

    // Pan/Zoom state
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isPanning = false;
    let panStartX = 0, panStartY = 0, startOffsetX = 0, startOffsetY = 0;
    let draggingId = null; let dragOffsetX = 0; let dragOffsetY = 0;
    // Visibility toggles (must exist before animation starts)
    let showThemes = true, showProjects = true;

    function worldToScreen(x, y) { return { x: (x * scale) + offsetX, y: (y * scale) + offsetY }; }
    function screenToWorld(x, y) { return { x: (x - offsetX) / scale, y: (y - offsetY) / scale }; }

    function hitNode(mx, my) {
        const { x: wx, y: wy } = screenToWorld(mx, my);
        let best = null, bestD = Infinity;
        for (const n of nodes) {
            const dx = n.x - wx, dy = n.y - wy; const d2 = dx*dx + dy*dy; if (d2 < (n.r+8)*(n.r+8) && d2 < bestD) { best = n; bestD = d2; }
        }
        return best;
    }

    canvas.addEventListener('pointerdown', (e) => {
        const n = hitNode(e.clientX, e.clientY);
        if (n) {
            draggingId = n.id;
            const { x: wx, y: wy } = screenToWorld(e.clientX, e.clientY);
            dragOffsetX = n.x - wx; dragOffsetY = n.y - wy;
            canvas.setPointerCapture(e.pointerId);
        } else {
            isPanning = true; panStartX = e.clientX; panStartY = e.clientY; startOffsetX = offsetX; startOffsetY = offsetY; canvas.setPointerCapture(e.pointerId);
        }
    });
    canvas.addEventListener('pointermove', (e) => {
        if (draggingId) {
            const n = getNode(draggingId);
            if (n) {
                const { x: wx, y: wy } = screenToWorld(e.clientX, e.clientY);
                const prevX = n.x, prevY = n.y;
                n.x = wx + dragOffsetX; n.y = wy + dragOffsetY; n.vx = 0; n.vy = 0; n.fixed = true;
                if (Math.hypot(n.x - prevX, n.y - prevY) > 0.5) justDragged = true;
            }
        } else if (isPanning) { offsetX = startOffsetX + (e.clientX - panStartX); offsetY = startOffsetY + (e.clientY - panStartY); }
    }, { passive: true });
    canvas.addEventListener('pointerup', (e) => { isPanning = false; draggingId = null; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointercancel', () => { isPanning = false; });
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY;
        const zoom = Math.exp(delta * 0.001);
        const mouseX = e.clientX, mouseY = e.clientY;
        const before = screenToWorld(mouseX, mouseY);
        scale = Math.min(2.0, Math.max(0.5, scale * zoom));
        const after = screenToWorld(mouseX, mouseY);
        offsetX += (before.x - after.x) * scale;
        offsetY += (before.y - after.y) * scale;
    }, { passive: false });

    // Hover / click
    const tooltip = document.getElementById('tooltip');
    let hoverId = null;
    function updateHover(mx, my) {
        const { x: wx, y: wy } = screenToWorld(mx, my);
        let best = null, bestD = Infinity;
        for (const n of nodes) {
            const dx = n.x - wx, dy = n.y - wy;
            const d2 = dx*dx + dy*dy;
            const rr = (n.r + 8) * (n.r + 8);
            if (d2 < rr && d2 < bestD) { best = n; bestD = d2; }
        }
        hoverId = best ? best.id : null;
        if (hoverId) {
            tooltip.textContent = best.label;
            tooltip.style.left = mx + 'px';
            tooltip.style.top = my + 'px';
            tooltip.style.display = 'block';
        } else {
            tooltip.style.display = 'none';
        }
    }
    window.addEventListener('pointermove', (e) => { updateHover(e.clientX, e.clientY); }, { passive: true });
    let justDragged = false;
    window.addEventListener('click', (e) => {
        if (justDragged) { justDragged = false; return; }
        if (!hoverId) return;
        const n = getNode(hoverId);
        if (n && n.href) {
            window.location.href = n.href;
        }
    });

    // Simulation tick
    function containNode(n) {
        if (!PARAMS.contain) return;
        const pad = 20; const minX = (-offsetX / scale) + pad; const minY = (-offsetY / scale) + pad; const maxX = (W() - offsetX) / scale - pad; const maxY = (H() - offsetY) / scale - pad;
        if (n.x < minX) { n.x = minX; n.vx *= -0.2; }
        if (n.x > maxX) { n.x = maxX; n.vx *= -0.2; }
        if (n.y < minY) { n.y = minY; n.vy *= -0.2; }
        if (n.y > maxY) { n.y = maxY; n.vy *= -0.2; }
    }

    function tick() {
        const cx = W() / 2, cy = H() / 2;
        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
            const a = nodes[i];
            if (!prefersReducedMotion) {
                const gx = (cx - a.x) * PARAMS.center; // center pull
                const gy = (cy - a.y) * PARAMS.center;
                a.vx += gx; a.vy += gy;
            }
            for (let j = i + 1; j < nodes.length; j++) {
                const b = nodes[j];
                let dx = a.x - b.x, dy = a.y - b.y;
                let d2 = dx*dx + dy*dy + 0.01;
                const f = PARAMS.repulse / d2;
                const fx = f * dx, fy = f * dy;
                a.vx += fx; a.vy += fy;
                b.vx -= fx; b.vy -= fy;
            }
        }
        // Springs
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            let dx = B.x - A.x, dy = B.y - A.y;
            const d = Math.max(0.001, Math.sqrt(dx*dx + dy*dy));
            const k = PARAMS.spring;
            const target = PARAMS.rest * (A.type === 'theme' || B.type === 'theme' ? 1.0 : 0.9);
            const diff = (d - target);
            const fx = (dx / d) * diff * k;
            const fy = (dy / d) * diff * k;
            A.vx += fx; A.vy += fy;
            B.vx -= fx; B.vy -= fy;
        }
        // Integrate
        for (const n of nodes) {
            if (prefersReducedMotion) continue; // static layout
            if (n.fixed) { n.vx = 0; n.vy = 0; containNode(n); continue; }
            n.vx *= PARAMS.damping; n.vy *= PARAMS.damping;
            n.x += n.vx * 0.02; n.y += n.vy * 0.02; containNode(n);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // world transform
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        // edges
        ctx.lineWidth = 1;
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            if ((A.type === 'theme' && !showThemes) || (A.type === 'project' && !showProjects)) continue;
            if ((B.type === 'theme' && !showThemes) || (B.type === 'project' && !showProjects)) continue;
            const alpha = (hoverId && (hoverId === A.id || hoverId === B.id)) ? 0.16 : 0.08;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            ctx.beginPath();
            // subtle curve: control point at mid plus slight normal offset
            const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
            const nx = (B.y - A.y), ny = -(B.x - A.x);
            const norm = Math.hypot(nx, ny) || 1;
            const off = 10;
            const cpx = mx + (nx / norm) * off; const cpy = my + (ny / norm) * off;
            ctx.moveTo(A.x, A.y);
            ctx.quadraticCurveTo(cpx, cpy, B.x, B.y);
            ctx.stroke();
        }
        // nodes
        for (const n of nodes) {
            if (n.type === 'theme' && !showThemes) continue;
            if (n.type === 'project' && !showProjects) continue;
            const isHover = hoverId === n.id;
            const rr = n.r;
            // glow
            if (n.type === 'theme') {
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.35 : 0.22})`;
                ctx.beginPath(); ctx.arc(n.x, n.y, rr + 6, 0, Math.PI * 2); ctx.fill();
            } else {
                // projects: highlight active ones with green glow
                if (n.active) {
                    // soft outer glow
                    ctx.save();
                    ctx.shadowColor = 'rgba(100, 255, 190, 0.35)';
                    ctx.shadowBlur = 14;
                    ctx.fillStyle = 'rgba(100, 255, 190, 0.18)';
                    ctx.beginPath(); ctx.arc(n.x, n.y, rr + 7, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                    // inner halo
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.22 : 0.12})`;
                } else {
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.28 : 0.16})`;
                }
                ctx.beginPath(); ctx.arc(n.x, n.y, rr + 4, 0, Math.PI * 2); ctx.fill();
            }
            // core
            ctx.fillStyle = 'rgba(10, 12, 20, 0.9)';
            ctx.beginPath(); ctx.arc(n.x, n.y, rr, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = n.active && n.type === 'project' ? 'rgba(100, 255, 190, 0.7)' : `rgba(${r}, ${g}, ${b}, ${isHover ? 0.9 : 0.55})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            // label (always readable, centered)
            ctx.fillStyle = n.active && n.type === 'project' ? 'rgba(190, 255, 230, 0.95)' : 'rgba(220, 230, 255, 0.9)';
            ctx.font = `${n.type === 'theme' ? 12 : 11}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const label = n.label;
            ctx.fillText(label, n.x, n.y + rr + 6);
        }
        ctx.restore();
    }

    function loop() {
        if (!prefersReducedMotion) tick();
        draw();
        requestAnimationFrame(loop);
    }
    // For reduced motion, pre-settle the layout with a few steps
    if (prefersReducedMotion) {
        for (let i = 0; i < 300; i++) tick();
        draw();
    }
    loop();

    // Controls wiring + persistence + legend toggles
    const qs = (id) => document.getElementById(id);
    const sliders = { repulse: qs('repulse'), spring: qs('spring'), rest: qs('rest') };
    const contain = qs('contain');
    const recenterBtn = qs('recenter');
    const resetBtn = qs('reset');
    const unpinBtn = qs('unpin');
    const toggleThemesBtn = document.getElementById('toggle-themes');
    const toggleProjectsBtn = document.getElementById('toggle-projects');

    function loadPrefs() {
        try {
            const raw = localStorage.getItem('constellation-prefs');
            if (!raw) return;
            const obj = JSON.parse(raw);
            Object.assign(PARAMS, obj.params || {});
            scale = obj.view?.scale ?? scale;
            offsetX = obj.view?.offsetX ?? offsetX;
            offsetY = obj.view?.offsetY ?? offsetY;
            (obj.pins || []).forEach(pin => { const n = getNode(pin.id); if (n) { n.x = pin.x; n.y = pin.y; n.fixed = true; } });
        } catch {}
    }
    function savePrefs() {
        try {
            const pins = nodes.filter(n => n.fixed).map(n => ({ id: n.id, x: n.x, y: n.y }));
            localStorage.setItem('constellation-prefs', JSON.stringify({ params: PARAMS, view: { scale, offsetX, offsetY }, pins }));
        } catch {}
    }
    loadPrefs();
    // reflect UI
    sliders.repulse.value = String(PARAMS.repulse);
    sliders.spring.value = String(Math.round(PARAMS.spring * 100));
    sliders.rest.value = String(PARAMS.rest);
    contain.checked = !!PARAMS.contain;
    // reflect legend state
    toggleThemesBtn.classList.toggle('off', !showThemes);
    toggleThemesBtn.setAttribute('aria-pressed', String(showThemes));
    toggleProjectsBtn.classList.toggle('off', !showProjects);
    toggleProjectsBtn.setAttribute('aria-pressed', String(showProjects));

    sliders.repulse.addEventListener('input', () => { PARAMS.repulse = Number(sliders.repulse.value); savePrefs(); });
    sliders.spring.addEventListener('input', () => { PARAMS.spring = Number(sliders.spring.value) / 100; savePrefs(); });
    sliders.rest.addEventListener('input', () => { PARAMS.rest = Number(sliders.rest.value); savePrefs(); });
    contain.addEventListener('change', () => { PARAMS.contain = contain.checked; savePrefs(); });
    recenterBtn.addEventListener('click', () => { offsetX = 0; offsetY = 0; scale = 1; savePrefs(); });
    resetBtn.addEventListener('click', () => { init(); savePrefs(); });
    unpinBtn.addEventListener('click', () => { nodes.forEach(n => n.fixed = false); savePrefs(); });

    toggleThemesBtn.addEventListener('click', () => {
        showThemes = !showThemes;
        if (!showThemes && !showProjects) { showProjects = true; toggleProjectsBtn.classList.remove('off'); toggleProjectsBtn.setAttribute('aria-pressed', 'true'); }
        toggleThemesBtn.classList.toggle('off', !showThemes);
        toggleThemesBtn.setAttribute('aria-pressed', String(showThemes));
    });
    toggleProjectsBtn.addEventListener('click', () => {
        showProjects = !showProjects;
        if (!showThemes && !showProjects) { showThemes = true; toggleThemesBtn.classList.remove('off'); toggleThemesBtn.setAttribute('aria-pressed', 'true'); }
        toggleProjectsBtn.classList.toggle('off', !showProjects);
        toggleProjectsBtn.setAttribute('aria-pressed', String(showProjects));
    });

    // Save occasionally
    setInterval(savePrefs, 1500);
    </script>
</body>
</html>


