<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation â€¢ Squad Pluto</title>
    <style>
        :root { --accent: #9ec2ff; --glow: rgba(160, 195, 255, 0.30); --radial-x: 50%; --radial-y: 45%; }
        #bg { position: fixed; inset: 0; z-index: 0; pointer-events: auto; display: block; }
        html, body { margin: 0; padding: 0; height: 100dvh; overflow: hidden; overscroll-behavior: none; background: radial-gradient(900px 600px at var(--radial-x) var(--radial-y), rgba(60, 70, 120, 0.18), rgba(0,0,0,0)), #020205; color: rgba(230, 235, 255, 0.9); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .ui { position: fixed; top: 12px; left: 12px; z-index: 2; display: flex; gap: 10px; align-items: center; }
        .legend { display: inline-flex; gap: 8px; align-items: center; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .legend-chip { display: inline-flex; gap: 8px; align-items: center; padding: 6px 8px; border-radius: 999px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.4); color: rgba(230, 235, 255, 0.92); cursor: pointer; }
        .legend-chip:hover { border-color: rgba(200, 220, 255, 0.5); }
        .legend-chip.off { opacity: 0.55; border-color: rgba(170, 200, 255, 0.18); }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .dot.theme { background: rgba(150, 200, 255, 0.9); box-shadow: 0 0 14px rgba(150, 200, 255, 0.35); border-radius: 3px; transform: rotate(45deg) scale(0.9); }
        .dot.project { background: rgba(200, 220, 255, 0.85); box-shadow: 0 0 10px rgba(200, 220, 255, 0.25); }
        .sep { width: 1px; height: 16px; background: rgba(170, 200, 255, 0.28); margin: 0 4px; }
        .btn { appearance: none; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); color: rgba(230, 235, 255, 0.92); padding: 8px 10px; border-radius: 10px; font-size: 12px; letter-spacing: 0.2px; text-decoration: none; cursor: pointer; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
        .btn:hover { border-color: rgba(200, 220, 255, 0.5); }
        .tooltip { position: fixed; z-index: 3; transform: translate(-50%, -120%); pointer-events: none; padding: 6px 8px; border-radius: 8px; font-size: 12px; color: rgba(235, 240, 255, 0.96); background: rgba(12, 14, 24, 0.85); border: 1px solid rgba(170, 200, 255, 0.28); display: none; }
        /* Controls panel (top-right) */
        .panel { position: fixed; top: 12px; right: 12px; z-index: 2; width: 260px; padding: 10px; border-radius: 12px; border: 1px solid rgba(170, 200, 255, 0.28); background: rgba(12, 14, 24, 0.6); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); color: rgba(230,235,255,0.92); }
        .panel h3 { margin: 0 0 8px; font-size: 13px; font-weight: 600; letter-spacing: .3px; color: rgba(210, 220, 255, 0.9); }
        .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 8px 0; }
        .row label { font-size: 12px; color: rgba(200, 210, 245, 0.9); }
        .row input[type="range"] { width: 140px; }
        .toggle { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .panel .actions { display: flex; gap: 6px; margin-top: 8px; }
        .panel .btn { padding: 6px 8px; font-size: 12px; }
        @media (prefers-reduced-motion: reduce) { .btn { transition: none; } }
    </style>
    <meta name="description" content="Interactive constellation map of Squad Pluto projects and themes." />
</head>
<body>
    <canvas id="bg"></canvas>
    <div class="ui">
        <div class="legend" aria-label="Legend">
            <button class="legend-chip" id="toggle-themes" aria-pressed="true" title="Toggle themes"><span class="dot theme"></span><span>Theme</span></button>
            <span class="sep"></span>
            <button class="legend-chip" id="toggle-projects" aria-pressed="true" title="Toggle projects"><span class="dot project"></span><span>Project</span></button>
        </div>
        <a class="btn" href="./index.html">Back to Home</a>
    </div>
    <div class="tooltip" id="tooltip" role="status" aria-live="polite"></div>
    <div class="panel" id="panel" aria-label="Controls">
        <h3>Constellation Controls</h3>
        <div class="row"><label for="repulse">Repulsion</label><input id="repulse" type="range" min="500" max="6000" step="100" value="3250"></div>
        <div class="row"><label for="spring">Spring</label><input id="spring" type="range" min="1" max="80" step="1" value="80"></div>
        <div class="row"><label for="rest">Rest length</label><input id="rest" type="range" min="40" max="160" step="2" value="90"></div>
        <div class="row"><label for="edgeScale">Line thickness</label><input id="edgeScale" type="range" min="50" max="200" step="5" value="100"></div>
        <div class="toggle"><input id="contain" type="checkbox"><label for="contain">Contain nodes in view</label></div>
        <div class="actions">
            <button class="btn" id="recenter">Recenter</button>
            <button class="btn" id="reset">Reset Layout</button>
            <button class="btn" id="unpin">Unpin All</button>
        </div>
    </div>
    <script>
    'use strict';
    // DPR setup
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
        const w = Math.floor(window.innerWidth);
        const h = Math.floor(window.innerHeight);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Colors
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#9ec2ff';
    function hexToRgb(hex) {
        const m = hex.replace('#', '');
        const int = parseInt(m, 16);
        if (m.length === 6 && !Number.isNaN(int)) { return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 }; }
        return { r: 158, g: 194, b: 255 };
    }
    const { r, g, b } = hexToRgb(accent);
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Seeded RNG for deterministic layout
    function mulberry32(a) { return function() { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    const rand = mulberry32(0xC0FFEE);

    // External data (provided by user)
    const DATA = {
        "themes": [
            { "id": "t-data", "label": "Data & AI", "color": "#9ec2ff" },
            { "id": "t-automation", "label": "Automation", "color": "#a9d2ff" },
            { "id": "t-vision", "label": "Vision", "color": "#b3e6ff" },
            { "id": "t-forecasting", "label": "Forecasting", "color": "#b6d7a8" },
            { "id": "t-knowledge", "label": "Knowledge", "color": "#c9c9ff" }
        ],
        "projects": [
            { "id": "p-sentinel", "label": "Sentinel", "href": "./sentinel.html", "active": true, "owners": ["HS"], "tags": ["anomaly", "alerting", "ops"], "summary": "Proactive anomaly detection and alerting platform for Ohme network issues." },
            { "id": "p-spp", "label": "Session Params Prediction", "href": "./session-params-prediction.html", "active": true, "owners": ["DS"], "tags": ["prediction", "charging", "energy"], "summary": "Predicts total kWh and SoC for charge sessions using historical data." },
            { "id": "p-crowdflex", "label": "Crowdflex", "href": "./crowdflex.html", "active": false, "owners": ["PLU"], "tags": ["flexibility", "grid", "demand"], "summary": "Energy flexibility initiatives coordinated with grid signals and incentives." },
            { "id": "p-jcv", "label": "Journey Computer Vision", "href": "./journey-computer-vision.html", "active": true, "owners": ["DS"], "tags": ["vision", "automation", "survey"], "summary": "Automates QA and feature extraction from customer-uploaded images." },
            { "id": "p-csa", "label": "Customer Success Agents", "href": "./customer-success-agents.html", "active": true, "owners": ["GB"], "tags": ["agents", "support", "llm"], "summary": "Agentic system for automated and suggested replies to customer queries." },
            { "id": "p-ecf", "label": "Energy Consumption Forecasting", "href": "./energy-consumption-forecasting.html", "active": true, "owners": ["HS"], "tags": ["forecasting", "energy", "prophet"], "summary": "Time series forecasting of half-hourly energy consumption per GSP." },
            { "id": "p-cx-engine", "label": "CX Engine", "href": "./cx-engine.html", "active": true, "owners": ["GB", "DS", "AM"], "tags": ["automation", "support", "workflow"], "summary": "Suite of automations for CX: tagging, summarisation, OOO filter, and more." },
            { "id": "p-cx-eval", "label": "CX Agents Evaluation", "href": "./cx-agents-evaluation.html", "active": true, "owners": ["DS", "GB"], "tags": ["evaluation", "agents", "coaching"], "summary": "AI-reviewed customer interactions for agent performance and coaching." },
            { "id": "p-pocs", "label": "POCs / Explorations", "href": "./pocs.html", "active": false, "owners": ["Squad Pluto"], "tags": ["prototype", "exploration"], "summary": "Rapid experiments and MVPs to de-risk ideas." }
        ],
        "edges": [
            { "a": "p-sentinel", "b": "t-data", "kind": "belongsTo", "weight": 0.9, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/3153723452/Sentinel"] },
            { "a": "p-sentinel", "b": "t-automation", "kind": "belongsTo", "weight": 0.8, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/3270803533/2025-09-25+-+Sentinel+Capability+Roadmap"] },
            { "a": "p-sentinel", "b": "t-vision", "kind": "belongsTo", "weight": 0.4, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/3270803533/2025-09-25+-+Sentinel+Capability+Roadmap"] },
            { "a": "p-spp", "b": "t-forecasting", "kind": "belongsTo", "weight": 0.9, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2808381544/SPP+-+Project+Page"] },
            { "a": "p-spp", "b": "t-data", "kind": "belongsTo", "weight": 0.6, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2808381544/SPP+-+Project+Page"] },
            { "a": "p-crowdflex", "b": "t-forecasting", "kind": "belongsTo", "weight": 0.8, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2247491696/V1+-+CrowdFlex+Energy+Demand+Forecasting"] },
            { "a": "p-jcv", "b": "t-vision", "kind": "belongsTo", "weight": 0.95, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2431975453/Journey+Computer+Vision"] },
            { "a": "p-jcv", "b": "t-automation", "kind": "belongsTo", "weight": 0.5, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2431975453/Journey+Computer+Vision"] },
            { "a": "p-csa", "b": "t-automation", "kind": "belongsTo", "weight": 0.8, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2755821643/Customer+Success+Agents+-+Project+Page"] },
            { "a": "p-csa", "b": "t-knowledge", "kind": "belongsTo", "weight": 0.6, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2625929223/High+Level+Overview"] },
            { "a": "p-ecf", "b": "t-forecasting", "kind": "belongsTo", "weight": 0.95, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2890727425/V2+-+ESO+Energy+Consumption+Forecasting+CF2"] },
            { "a": "p-ecf", "b": "t-data", "kind": "belongsTo", "weight": 0.5, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2890727425/V2+-+ESO+Energy+Consumption+Forecasting+CF2"] },
            { "a": "p-cx-engine", "b": "t-automation", "kind": "belongsTo", "weight": 0.9, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2832466006/CX+Engine+-+Project+Page"] },
            { "a": "p-cx-engine", "b": "t-knowledge", "kind": "belongsTo", "weight": 0.5, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2832466006/CX+Engine+-+Project+Page"] },
            { "a": "p-cx-eval", "b": "t-knowledge", "kind": "belongsTo", "weight": 0.8, "sources": ["./cx-agents-evaluation.html"] },
            { "a": "p-cx-eval", "b": "t-automation", "kind": "belongsTo", "weight": 0.5, "sources": ["./cx-agents-evaluation.html"] },
            { "a": "p-pocs", "b": "t-data", "kind": "belongsTo", "weight": 0.5, "sources": ["./pocs.html"] },
            { "a": "p-sentinel", "b": "p-spp", "kind": "related", "weight": 0.4, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/3270803533/2025-09-25+-+Sentinel+Capability+Roadmap", "https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2808381544/SPP+-+Project+Page"] },
            { "a": "p-ecf", "b": "p-crowdflex", "kind": "related", "weight": 0.6, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2890727425/V2+-+ESO+Energy+Consumption+Forecasting+CF2", "https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2247491696/V1+-+CrowdFlex+Energy+Demand+Forecasting"] },
            { "a": "p-csa", "b": "p-cx-engine", "kind": "related", "weight": 0.4, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2755821643/Customer+Success+Agents+-+Project+Page", "https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2832466006/CX+Engine+-+Project+Page"] },
            { "a": "t-automation", "b": "t-data", "kind": "related", "weight": 0.3, "sources": ["https://ohmenergy.atlassian.net/wiki/spaces/DS/pages/2832531577/Project+Ownership+Log"] }
        ],
        "settings": {
            "notes": "All projects mapped to at least one theme. Activeness based on recent updates and labels. Edges reflect shared tags, interlinks, and topical similarity."
        }
    };

    // Data model (from DATA)
    const themes = DATA.themes.map(t => ({ id: t.id, label: t.label, color: t.color || accent }));
    const projects = DATA.projects.map(p => ({ id: p.id, label: p.label, href: p.href, active: !!p.active, owners: p.owners || [], tags: p.tags || [], summary: p.summary || '' }));
    const edgesRaw = DATA.edges.map(e => ({ a: e.a, b: e.b, kind: e.kind || 'related', weight: (typeof e.weight === 'number' ? e.weight : 0.5) }));

    const nodes = [];
    const edges = [];
    // Theme color map
    const themeRgbById = {};
    for (const t of themes) { themeRgbById[t.id] = hexToRgb(t.color || accent); }
    const W = () => canvas.width / dpr, H = () => canvas.height / dpr;

    // Initialize node positions in a ring for stability
    function init() {
        nodes.length = 0; edges.length = 0;
        const cx = W() / 2, cy = H() / 2;
        const themeRadius = Math.min(cx, cy) * 0.45;
        const projRadius = Math.min(cx, cy) * 0.25;
        themes.forEach((t, i) => {
            const a = (i / themes.length) * Math.PI * 2;
            nodes.push({ id: t.id, label: t.label, type: 'theme', x: cx + Math.cos(a) * themeRadius, y: cy + Math.sin(a) * themeRadius, vx: 0, vy: 0, r: 12, fixed: false });
        });
        projects.forEach((p, i) => {
            const a = (i / projects.length) * Math.PI * 2 + 0.2;
            nodes.push({ id: p.id, label: p.label, type: 'project', href: p.href, active: !!p.active, owners: p.owners, tags: p.tags, summary: p.summary, x: cx + Math.cos(a) * projRadius, y: cy + Math.sin(a) * projRadius, vx: 0, vy: 0, r: 7, fixed: false });
        });
        // use provided edges
        edges.push(...edgesRaw);
    }
    init();

    function getNode(id) { return nodes.find(n => n.id === id); }

    // Physics parameters
    let PARAMS = {
        repulse: 3250,
        spring: 0.8,
        damping: 0.9,
        center: 0.02,
        rest: 90,
        contain: false,
        edgeScale: 1.0
    };

    // Pan/Zoom state
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isPanning = false;
    let panStartX = 0, panStartY = 0, startOffsetX = 0, startOffsetY = 0;
    let draggingId = null; let dragOffsetX = 0; let dragOffsetY = 0;
    // Visibility toggles (must exist before animation starts)
    let showThemes = true, showProjects = true;

    function worldToScreen(x, y) { return { x: (x * scale) + offsetX, y: (y * scale) + offsetY }; }
    function screenToWorld(x, y) { return { x: (x - offsetX) / scale, y: (y - offsetY) / scale }; }

    function hitNode(mx, my) {
        const { x: wx, y: wy } = screenToWorld(mx, my);
        let best = null, bestD = Infinity;
        for (const n of nodes) {
            const dx = n.x - wx, dy = n.y - wy; const d2 = dx*dx + dy*dy; if (d2 < (n.r+8)*(n.r+8) && d2 < bestD) { best = n; bestD = d2; }
        }
        return best;
    }

    canvas.addEventListener('pointerdown', (e) => {
        const n = hitNode(e.clientX, e.clientY);
        if (n) {
            draggingId = n.id;
            const { x: wx, y: wy } = screenToWorld(e.clientX, e.clientY);
            dragOffsetX = n.x - wx; dragOffsetY = n.y - wy;
            canvas.setPointerCapture(e.pointerId);
        } else {
            isPanning = true; panStartX = e.clientX; panStartY = e.clientY; startOffsetX = offsetX; startOffsetY = offsetY; canvas.setPointerCapture(e.pointerId);
        }
    });
    canvas.addEventListener('pointermove', (e) => {
        if (draggingId) {
            const n = getNode(draggingId);
            if (n) {
                const { x: wx, y: wy } = screenToWorld(e.clientX, e.clientY);
                const prevX = n.x, prevY = n.y;
                n.x = wx + dragOffsetX; n.y = wy + dragOffsetY; n.vx = 0; n.vy = 0; n.fixed = true;
                if (Math.hypot(n.x - prevX, n.y - prevY) > 0.5) justDragged = true;
            }
        } else if (isPanning) { offsetX = startOffsetX + (e.clientX - panStartX); offsetY = startOffsetY + (e.clientY - panStartY); }
    }, { passive: true });
    canvas.addEventListener('pointerup', (e) => { isPanning = false; draggingId = null; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointercancel', () => { isPanning = false; });
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY;
        const zoom = Math.exp(delta * 0.001);
        const mouseX = e.clientX, mouseY = e.clientY;
        const before = screenToWorld(mouseX, mouseY);
        scale = Math.min(2.0, Math.max(0.5, scale * zoom));
        const after = screenToWorld(mouseX, mouseY);
        offsetX += (before.x - after.x) * scale;
        offsetY += (before.y - after.y) * scale;
    }, { passive: false });

    // Hover / click
    const tooltip = document.getElementById('tooltip');
    let hoverId = null;
    function updateHover(mx, my) {
        const { x: wx, y: wy } = screenToWorld(mx, my);
        let best = null, bestD = Infinity;
        for (const n of nodes) {
            const dx = n.x - wx, dy = n.y - wy;
            const d2 = dx*dx + dy*dy;
            const rr = (n.r + 8) * (n.r + 8);
            if (d2 < rr && d2 < bestD) { best = n; bestD = d2; }
        }
        hoverId = best ? best.id : null;
        if (hoverId) {
            // Tooltip: label + optional summary for projects
            if (best.type === 'project' && best.summary) {
                tooltip.textContent = best.label + ' â€” ' + best.summary;
            } else {
                tooltip.textContent = best.label;
            }
            tooltip.style.left = mx + 'px';
            tooltip.style.top = my + 'px';
            tooltip.style.display = 'block';
        } else {
            tooltip.style.display = 'none';
        }
    }
    window.addEventListener('pointermove', (e) => { updateHover(e.clientX, e.clientY); }, { passive: true });
    let justDragged = false;
    window.addEventListener('click', (e) => {
        if (justDragged) { justDragged = false; return; }
        if (!hoverId) return;
        const n = getNode(hoverId);
        if (n && n.href) {
            window.location.href = n.href;
        }
    });

    // Simulation tick
    function containNode(n) {
        if (!PARAMS.contain) return;
        const pad = 20; const minX = (-offsetX / scale) + pad; const minY = (-offsetY / scale) + pad; const maxX = (W() - offsetX) / scale - pad; const maxY = (H() - offsetY) / scale - pad;
        if (n.x < minX) { n.x = minX; n.vx *= -0.2; }
        if (n.x > maxX) { n.x = maxX; n.vx *= -0.2; }
        if (n.y < minY) { n.y = minY; n.vy *= -0.2; }
        if (n.y > maxY) { n.y = maxY; n.vy *= -0.2; }
    }

    function tick() {
        const cx = W() / 2, cy = H() / 2;
        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
            const a = nodes[i];
            if (!prefersReducedMotion) {
                const gx = (cx - a.x) * PARAMS.center; // center pull
                const gy = (cy - a.y) * PARAMS.center;
                a.vx += gx; a.vy += gy;
            }
            for (let j = i + 1; j < nodes.length; j++) {
                const b = nodes[j];
                let dx = a.x - b.x, dy = a.y - b.y;
                let d2 = dx*dx + dy*dy + 0.01;
                const f = PARAMS.repulse / d2;
                const fx = f * dx, fy = f * dy;
                a.vx += fx; a.vy += fy;
                b.vx -= fx; b.vy -= fy;
            }
        }
        // Springs (by edge kind and weight)
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            let dx = B.x - A.x, dy = B.y - A.y;
            const d = Math.max(0.001, Math.sqrt(dx*dx + dy*dy));
            const weight = Math.max(0.1, Math.min(1.0, e.weight || 0.4));
            const isBelongs = e.kind === 'belongsTo';
            const k = PARAMS.spring * (isBelongs ? (0.6 + 0.6 * weight) : (0.5 + 0.5 * weight));
            const target = PARAMS.rest * (isBelongs ? 1.0 : 1.2);
            const diff = (d - target);
            const fx = (dx / d) * diff * k;
            const fy = (dy / d) * diff * k;
            A.vx += fx; A.vy += fy;
            B.vx -= fx; B.vy -= fy;
        }
        // Integrate
        for (const n of nodes) {
            if (prefersReducedMotion) continue; // static layout
            if (n.fixed) { n.vx = 0; n.vy = 0; containNode(n); continue; }
            n.vx *= PARAMS.damping; n.vy *= PARAMS.damping;
            n.x += n.vx * 0.02; n.y += n.vy * 0.02; containNode(n);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // world transform
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        // edges
        for (const e of edges) {
            const A = getNode(e.a), B = getNode(e.b);
            if ((A.type === 'theme' && !showThemes) || (A.type === 'project' && !showProjects)) continue;
            if ((B.type === 'theme' && !showThemes) || (B.type === 'project' && !showProjects)) continue;
            const w = (Math.max(0.6, 0.6 + 1.2 * (e.weight || 0.4))) * (PARAMS.edgeScale || 1.0);
            const baseAlpha = (hoverId && (hoverId === A.id || hoverId === B.id)) ? 0.16 : 0.08;
            const alpha = Math.min(0.36, baseAlpha + 0.24 * (e.weight || 0.4));
            let cr = r, cg = g, cb = b;
            if (e.kind === 'belongsTo') {
                const themeNode = A.type === 'theme' ? A : (B.type === 'theme' ? B : null);
                if (themeNode && themeRgbById[themeNode.id]) {
                    const c = themeRgbById[themeNode.id]; cr = c.r; cg = c.g; cb = c.b;
                }
            }
            ctx.lineWidth = w;
            ctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, ${alpha})`;
            ctx.beginPath();
            // subtle curve: control point at mid plus slight normal offset
            const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
            const nx = (B.y - A.y), ny = -(B.x - A.x);
            const norm = Math.hypot(nx, ny) || 1;
            const off = 10;
            const cpx = mx + (nx / norm) * off; const cpy = my + (ny / norm) * off;
            ctx.moveTo(A.x, A.y);
            ctx.quadraticCurveTo(cpx, cpy, B.x, B.y);
            ctx.stroke();
        }
        // nodes
        for (const n of nodes) {
            if (n.type === 'theme' && !showThemes) continue;
            if (n.type === 'project' && !showProjects) continue;
            const isHover = hoverId === n.id;
            const rr = n.r;
            // glow + shape prep
            if (n.type === 'theme') {
                // Diamond glow and dashed ring
                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(Math.PI / 4);
                const tc = themeRgbById[n.id] || { r, g, b };
                ctx.fillStyle = `rgba(${tc.r}, ${tc.g}, ${tc.b}, ${isHover ? 0.32 : 0.20})`;
                ctx.beginPath();
                ctx.rect(-(rr + 6), -(rr + 6), (rr + 6) * 2, (rr + 6) * 2);
                ctx.fill();
                ctx.strokeStyle = `rgba(${tc.r}, ${tc.g}, ${tc.b}, ${isHover ? 0.7 : 0.45})`;
                ctx.setLineDash([4, 3]);
                ctx.lineWidth = 1;
                ctx.strokeRect(-(rr + 2), -(rr + 2), (rr + 2) * 2, (rr + 2) * 2);
                ctx.setLineDash([]);
                ctx.restore();
            } else {
                // projects: highlight active ones with green glow
                if (n.active) {
                    // soft outer glow (draw before core to ensure visibility)
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = 'rgba(100, 255, 190, 0.18)';
                    for (let k = 0; k < 2; k++) {
                        ctx.beginPath(); ctx.arc(n.x, n.y, rr + 7 + k, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                    // inner halo tint
                    ctx.fillStyle = `rgba(100, 255, 190, ${isHover ? 0.10 : 0.06})`;
                } else {
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isHover ? 0.28 : 0.16})`;
                }
                ctx.beginPath(); ctx.arc(n.x, n.y, rr + 4, 0, Math.PI * 2); ctx.fill();
            }
            // core (shape-specific)
            if (n.type === 'theme') {
                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(Math.PI / 4);
                ctx.fillStyle = 'rgba(10, 12, 20, 0.9)';
                ctx.beginPath(); ctx.rect(-rr, -rr, rr * 2, rr * 2); ctx.fill();
                const tc = themeRgbById[n.id] || { r, g, b };
                ctx.strokeStyle = `rgba(${tc.r}, ${tc.g}, ${tc.b}, ${isHover ? 0.9 : 0.55})`;
                ctx.lineWidth = 1; ctx.strokeRect(-rr, -rr, rr * 2, rr * 2);
                ctx.restore();
            } else {
                ctx.fillStyle = 'rgba(10, 12, 20, 0.9)';
                ctx.beginPath(); ctx.arc(n.x, n.y, rr, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = n.active && n.type === 'project' ? 'rgba(100, 255, 190, 0.7)' : `rgba(${r}, ${g}, ${b}, ${isHover ? 0.9 : 0.55})`;
                ctx.lineWidth = 1; ctx.stroke();
            }
            // label (always readable, centered)
            if (n.type === 'theme') {
                const tc = themeRgbById[n.id] || { r: 190, g: 210, b: 255 };
                ctx.fillStyle = `rgba(${Math.min(255, tc.r + 30)}, ${Math.min(255, tc.g + 30)}, ${Math.min(255, tc.b + 30)}, 0.92)`;
            } else {
                ctx.fillStyle = n.active ? 'rgba(190, 255, 230, 0.95)' : 'rgba(220, 230, 255, 0.9)';
            }
            ctx.font = `${n.type === 'theme' ? 12 : 11}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const label = n.label;
            ctx.fillText(label, n.x, n.y + rr + 6);
        }
        ctx.restore();
    }

    function loop() {
        if (!prefersReducedMotion) tick();
        draw();
        requestAnimationFrame(loop);
    }
    // For reduced motion, pre-settle the layout with a few steps
    if (prefersReducedMotion) {
        for (let i = 0; i < 300; i++) tick();
        draw();
    }
    loop();

    // Controls wiring + persistence + legend toggles
    const qs = (id) => document.getElementById(id);
    const sliders = { repulse: qs('repulse'), spring: qs('spring'), rest: qs('rest'), edgeScale: qs('edgeScale') };
    const contain = qs('contain');
    const recenterBtn = qs('recenter');
    const resetBtn = qs('reset');
    const unpinBtn = qs('unpin');
    const toggleThemesBtn = document.getElementById('toggle-themes');
    const toggleProjectsBtn = document.getElementById('toggle-projects');

    function loadPrefs() {
        try {
            const raw = localStorage.getItem('constellation-prefs');
            if (!raw) return;
            const obj = JSON.parse(raw);
            Object.assign(PARAMS, obj.params || {});
            scale = obj.view?.scale ?? scale;
            offsetX = obj.view?.offsetX ?? offsetX;
            offsetY = obj.view?.offsetY ?? offsetY;
            (obj.pins || []).forEach(pin => { const n = getNode(pin.id); if (n) { n.x = pin.x; n.y = pin.y; n.fixed = true; } });
        } catch {}
    }
    function savePrefs() {
        try {
            const pins = nodes.filter(n => n.fixed).map(n => ({ id: n.id, x: n.x, y: n.y }));
            localStorage.setItem('constellation-prefs', JSON.stringify({ params: PARAMS, view: { scale, offsetX, offsetY }, pins }));
        } catch {}
    }
    loadPrefs();
    // reflect UI
    sliders.repulse.value = String(PARAMS.repulse);
    sliders.spring.value = String(Math.round(PARAMS.spring * 100));
    sliders.rest.value = String(PARAMS.rest);
    contain.checked = !!PARAMS.contain;
    sliders.edgeScale.value = String(Math.round((PARAMS.edgeScale || 1.0) * 100));
    // reflect legend state
    toggleThemesBtn.classList.toggle('off', !showThemes);
    toggleThemesBtn.setAttribute('aria-pressed', String(showThemes));
    toggleProjectsBtn.classList.toggle('off', !showProjects);
    toggleProjectsBtn.setAttribute('aria-pressed', String(showProjects));

    sliders.repulse.addEventListener('input', () => { PARAMS.repulse = Number(sliders.repulse.value); savePrefs(); });
    sliders.spring.addEventListener('input', () => { PARAMS.spring = Number(sliders.spring.value) / 100; savePrefs(); });
    sliders.rest.addEventListener('input', () => { PARAMS.rest = Number(sliders.rest.value); savePrefs(); });
    sliders.edgeScale.addEventListener('input', () => { PARAMS.edgeScale = Number(sliders.edgeScale.value) / 100; savePrefs(); });
    contain.addEventListener('change', () => { PARAMS.contain = contain.checked; savePrefs(); });
    recenterBtn.addEventListener('click', () => { offsetX = 0; offsetY = 0; scale = 1; savePrefs(); });
    resetBtn.addEventListener('click', () => { init(); savePrefs(); });
    unpinBtn.addEventListener('click', () => { nodes.forEach(n => n.fixed = false); savePrefs(); });

    toggleThemesBtn.addEventListener('click', () => {
        showThemes = !showThemes;
        if (!showThemes && !showProjects) { showProjects = true; toggleProjectsBtn.classList.remove('off'); toggleProjectsBtn.setAttribute('aria-pressed', 'true'); }
        toggleThemesBtn.classList.toggle('off', !showThemes);
        toggleThemesBtn.setAttribute('aria-pressed', String(showThemes));
    });
    toggleProjectsBtn.addEventListener('click', () => {
        showProjects = !showProjects;
        if (!showThemes && !showProjects) { showThemes = true; toggleThemesBtn.classList.remove('off'); toggleThemesBtn.setAttribute('aria-pressed', 'true'); }
        toggleProjectsBtn.classList.toggle('off', !showProjects);
        toggleProjectsBtn.setAttribute('aria-pressed', String(showProjects));
    });

    // Save occasionally
    setInterval(savePrefs, 1500);
    </script>
</body>
</html>


