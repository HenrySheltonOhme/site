<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Loom - The Architect of the Abstract</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #000000;
            cursor: crosshair;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #instruction {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 18px;
            pointer-events: none;
            transition: opacity 2s;
            text-align: center;
            line-height: 1.6;
        }
        #instruction.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="loom"></canvas>
    <div id="instruction">
        Move your mouse to weave threads of light<br>
        <span style="font-size: 14px; opacity: 0.7;">Each thread lives, breathes, and fades into memory</span>
    </div>
    <script>
        const canvas = document.getElementById('loom');
        const ctx = canvas.getContext('2d');
        const instruction = document.getElementById('instruction');

        function resizeCanvas() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const threads = [];
        let mouseX = 0, mouseY = 0, prevMouseX = 0, prevMouseY = 0;
        let isMouseMoving = false, lastMoveTime = 0, currentThread = null;

        const CONFIG = {
            THREAD_LIFETIME: 4000,
            POINT_DISTANCE: 8,
            LINE_WIDTH: 2.5,
            MOTION_BLUR: 0.15,
            VELOCITY_COLOR_SCALE: 0.03,
            OSCILLATION_FREQUENCY: 0.002,
            OSCILLATION_AMPLITUDE: 0.5,
        };

        class Thread {
            constructor(x, y, velocity) {
                this.points = [{x, y}];
                this.birthTime = Date.now();
                this.velocity = velocity;
                const hue = Math.min(velocity * CONFIG.VELOCITY_COLOR_SCALE, 60) + (velocity < 10 ? 200 : 0);
                const saturation = 70 + Math.min(velocity * 0.2, 30);
                const lightness = 50 + Math.min(velocity * 0.1, 20);
                this.baseColor = { h: hue % 360, s: saturation, l: lightness };
            }

            addPoint(x, y) {
                const lastPoint = this.points[this.points.length - 1];
                const distance = Math.hypot(x - lastPoint.x, y - lastPoint.y);
                if (distance > CONFIG.POINT_DISTANCE) {
                    this.points.push({x, y});
                }
            }

            getLifePhase() {
                const age = Date.now() - this.birthTime;
                const lifeRatio = age / CONFIG.THREAD_LIFETIME;
                if (lifeRatio >= 1) return 0;
                if (lifeRatio < 0.5) return 1;
                return 1 - Math.pow((lifeRatio - 0.5) * 2, 2);
            }

            isDead() {
                return this.getLifePhase() <= 0;
            }

            draw(time) {
                if (this.points.length < 2) return;
                const opacity = this.getLifePhase();
                if (opacity <= 0) return;

                const age = Date.now() - this.birthTime;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = CONFIG.LINE_WIDTH;

                const lifeFade = this.getLifePhase();
                const h = (this.baseColor.h + (1 - lifeFade) * 30) % 360;
                const s = this.baseColor.s * (0.3 + lifeFade * 0.7);
                const l = this.baseColor.l * lifeFade;
                ctx.strokeStyle = `hsla(${h}, ${s}%, ${l}%, ${opacity})`;

                ctx.beginPath();
                for (let i = 0; i < this.points.length - 1; i++) {
                    const p0 = this.points[Math.max(0, i - 1)];
                    const p1 = this.points[i];
                    const p2 = this.points[i + 1];
                    const p3 = this.points[Math.min(this.points.length - 1, i + 2)];
                    const oscillation = Math.sin(age * CONFIG.OSCILLATION_FREQUENCY + i * 0.5) * CONFIG.OSCILLATION_AMPLITUDE * lifeFade;

                    if (i === 0) {
                        ctx.moveTo(p1.x, p1.y + oscillation);
                    }

                    const cp1x = p1.x + (p2.x - p0.x) / 6;
                    const cp1y = p1.y + (p2.y - p0.y) / 6 + oscillation;
                    const cp2x = p2.x - (p3.x - p1.x) / 6;
                    const cp2y = p2.y - (p3.y - p1.y) / 6 + oscillation;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y + oscillation);
                }
                ctx.stroke();

                if (opacity > 0.5) {
                    ctx.lineWidth = CONFIG.LINE_WIDTH * 3;
                    ctx.strokeStyle = `hsla(${h}, ${s}%, ${l}%, ${opacity * 0.2})`;
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseMoving = true;
            lastMoveTime = Date.now();

            if (!instruction.classList.contains('hidden')) {
                instruction.classList.add('hidden');
            }

            const velocity = Math.hypot(mouseX - prevMouseX, mouseY - prevMouseY);

            if (!currentThread) {
                currentThread = new Thread(mouseX, mouseY, velocity);
                threads.push(currentThread);
            } else {
                currentThread.addPoint(mouseX, mouseY);
                if (velocity > 5) {
                    const hue = Math.min(velocity * CONFIG.VELOCITY_COLOR_SCALE, 60) + (velocity < 10 ? 200 : 0);
                    currentThread.baseColor.h = hue % 360;
                }
            }
        });

        setInterval(() => {
            if (Date.now() - lastMoveTime > 100) {
                isMouseMoving = false;
                currentThread = null;
            }
        }, 50);

        function animate(time) {
            ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.MOTION_BLUR})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            threads.forEach(thread => {
                thread.draw(time);
            });

            for (let i = threads.length - 1; i >= 0; i--) {
                if (threads[i].isDead()) {
                    threads.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        animate(0);
    </script>
</body>
</html>
