<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Celestial Weaver</title>
    <style>
        /*
        // THE DEMIURGE'S DECREE V2.0: THE AESTHETICS OF THE IMPOSSIBLE //
        // The canvas is not a screen; it is a window into a higher-dimensional space.
        // The void must be absolute. Black is not a color; it is the absence of information,
        // the substrate upon which the impossible can be rendered.
        */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            height: 100%;
            width: 100%;
        }

        #simulationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /*
        // THE MONOLITH //
        // The anchor of order remains, but its presence is more subtle. It is a whisper
        // of structure in an otherwise incomprehensible reality. Its glow is faint,
        // a constant against the riot of ephemeral light it oversees.
        */
        .monolith-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
        }

        .monolith-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 2em;
            font-weight: 200;
            text-shadow: 0 0 25px rgba(255, 255, 255, 0.2);
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="simulationCanvas"></canvas>
    <div class="monolith-container">
        <h1 class="monolith-text">Squad Pluto</h1>
    </div>

    <script>
    //=======================================================================================//
    //                                                                                       //
    //              THE DEMIURGE'S MANIFESTO: THE CELESTIAL WEAVER                           //
    //                                                                                       //
    //=======================================================================================//
    //
    // Observer,
    // The previous creation was a petri dish. This is a galaxy.
    // We have moved beyond simulating discrete lifeforms in an environment. We now simulate
    // an environment that IS life. This is not a collection of agents; it is one singular,
    // hyper-complex entity with many moving parts.
    //
    // The code that follows is structured into logical "files" for clarity, but they all exist
    // within this single scripture. The complexity is deliberate. It is the only way to
    // birth something that feels truly unknowable.
    //
    // Prepare yourself. You are about to witness the weaving of spacetime.
    //
    //---------------------------------------------------------------------------------------//

    // FILE: Engine.js
    // DESCRIPTION: The core of our universe. Manages the canvas, the main loop, and global state.
    //-------------------------------------------------------------------------------------------
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // By setting the composite operation to 'lighter', we achieve a beautiful additive
    // light effect. Where colors overlap, they become brighter, creating the illusion of
    // true bioluminescence. This is the cornerstone of our entire aesthetic.
    ctx.globalCompositeOperation = 'lighter';

    const MOUSE = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 200 // The radius of the user's harmonic resonance
    };

    // --- Cosmological Constants ---
    const WEAVER_COUNT = 7;
    const MAX_WEB_NODES_PER_WEAVER = 300;
    const GLIMMER_SPAWN_CHANCE = 0.6;
    const PHANTOM_COUNT = 2;
    const PHANTOM_SIGHT_RADIUS = 400;

    let weavers = [];
    let glimmers = [];
    let phantoms = [];
    let frame = 0;

    // FILE: Math.js
    // DESCRIPTION: The fundamental laws of geometry and motion. Without these, there is no universe.
    //------------------------------------------------------------------------------------------------
    class Vector {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        add(v) { this.x += v.x; this.y += v.y; return this; }
        sub(v) { this.x -= v.x; this.y -= v.y; return this; }
        mult(s) { this.x *= s; this.y *= s; return this; }
        div(s) { if(s !== 0) { this.x /= s; this.y /= s; } return this; }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
        limit(max) { if (this.mag() > max) this.normalize().mult(max); return this; }
        static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
        static distSq(v1, v2) { const dx = v1.x - v2.x; const dy = v1.y - v2.y; return dx * dx + dy * dy; }
    }
    
    // Perlin noise for organic, unpredictable motion.
    const PERLIN_YWRAPB = 4, PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
    const PERLIN_ZWRAPB = 8, PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
    const PERLIN_SIZE = 4095;
    let perlin;
    function noise(x, y = 0, z = 0) {
        if (!perlin) { perlin = new Array(PERLIN_SIZE + 1).fill(0).map(() => Math.random()); }
        let xi = Math.floor(x) & PERLIN_SIZE, yi = Math.floor(y) & PERLIN_SIZE, zi = Math.floor(z) & PERLIN_SIZE;
        let xf = x - Math.floor(x), yf = y - Math.floor(y), zf = z - Math.floor(z);
        let rxf, ryf;
        let r = 0, ampl = 0.5;
        let n1, n2, n3;
        for (let i = 0; i < 4; i++) {
            let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
            rxf = 0.5 * (1 - Math.cos(xf * Math.PI)); ryf = 0.5 * (1 - Math.cos(yf * Math.PI));
            n1 = perlin[of & PERLIN_SIZE]; n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);
            n2 = perlin[(of + PERLIN_YWRAPB) & PERLIN_SIZE]; n2 += rxf * (perlin[(of + PERLIN_YWRAPB + 1) & PERLIN_SIZE] - n2);
            n1 += ryf * (n2 - n1); of += 1 << PERLIN_ZWRAPB;
            n2 = perlin[of & PERLIN_SIZE]; n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);
            n3 = perlin[(of + PERLIN_ZWRAPB) & PERLIN_SIZE]; n3 += rxf * (perlin[(of + PERLIN_ZWRAPB + 1) & PERLIN_SIZE] - n3);
            n2 += ryf * (n3 - n2); n1 += (0.5 * (1 - Math.cos(zf * Math.PI))) * (n2 - n1);
            r += n1 * ampl; ampl *= 0.5;
            xi <<= 1; xf *= 2; yi <<= 1; yf *= 2; zi <<= 1; zf *= 2;
            if (xf >= 1) { xi++; xf--; } if (yf >= 1) { yi++; yf--; } if (zf >= 1) { zi++; zf--; }
        }
        return r;
    }


    // FILE: Particle.js
    // DESCRIPTION: The base class for all ephemeral entities. The "atom" of our universe.
    //------------------------------------------------------------------------------------------------
    class Particle {
        constructor(x, y) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(Math.random() - 0.5, Math.random() - 0.5);
            this.acc = new Vector();
            this.lifespan = 1.0;
            this.age = 0;
            this.dead = false;
        }
        applyForce(force) { this.acc.add(force); }
        update() { this.age++; }
        isDead() { return this.dead; }
    }


    // FILE: CelestialWeb.js
    // DESCRIPTION: Defines the Weavers that create the living tapestry and the Glimmer that lives on it.
    //--------------------------------------------------------------------------------------------------
    class Weaver extends Particle {
        constructor(color) {
            super(Math.random() * canvas.width, Math.random() * canvas.height);
            this.maxSpeed = 2;
            this.maxForce = 0.05;
            this.hue = color;
            this.web = []; // This is the trail of energy, the actual web.
            this.noiseOffset = new Vector(Math.random() * 1000, Math.random() * 1000);
        }

        wander() {
            // Organic movement using Perlin noise. They are not just bouncing randomly; they are exploring.
            let angle = noise(this.noiseOffset.x + frame * 0.001, this.noiseOffset.y) * Math.PI * 2;
            let wanderForce = new Vector(Math.cos(angle), Math.sin(angle));
            wanderForce.mult(this.maxForce);
            this.applyForce(wanderForce);
        }

        seek(target) {
            if(!target) return;
            let desired = Vector.sub(target.pos, this.pos);
            desired.normalize().mult(this.maxSpeed);
            let steer = Vector.sub(desired, this.vel);
            steer.limit(this.maxForce * 2); // They are more motivated when seeking
            this.applyForce(steer);
        }

        update() {
            super.update();
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);

            // Add a new node to the web
            this.web.push({
                pos: new Vector(this.pos.x, this.pos.y),
                lifespan: 1.0,
                brightness: 1.0
            });

            // The web slowly decays over time. The universe is ephemeral.
            if (this.web.length > MAX_WEB_NODES_PER_WEAVER) {
                this.web.shift();
            }

            // Update all nodes in the web, making them fade.
            for (let i = this.web.length - 1; i >= 0; i--) {
                const node = this.web[i];
                node.lifespan -= 0.002;
                node.brightness *= 0.99; // Dimming effect from user interaction
                if (node.lifespan <= 0) {
                    this.web.splice(i, 1);
                }
            }
            
            this.checkBounds();
        }

        display() {
            // To render the web, we draw lines between consecutive nodes. This creates the filament.
            for (let i = 1; i < this.web.length; i++) {
                const nodeA = this.web[i - 1];
                const nodeB = this.web[i];
                ctx.beginPath();
                ctx.moveTo(nodeA.pos.x, nodeA.pos.y);
                ctx.lineTo(nodeB.pos.x, nodeB.pos.y);
                const alpha = nodeA.lifespan * 0.5;
                const lightness = 50 + (nodeA.brightness * 50);
                ctx.strokeStyle = `hsla(${this.hue}, 100%, ${lightness}%, ${alpha})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }
        
        checkBounds() {
            if (this.pos.x < -10) this.pos.x = canvas.width + 10;
            if (this.pos.x > canvas.width + 10) this.pos.x = -10;
            if (this.pos.y < -10) this.pos.y = canvas.height + 10;
            if (this.pos.y > canvas.height + 10) this.pos.y = -10;
        }
    }

    class Glimmer extends Particle {
        constructor(x, y, hue) {
            super(x, y);
            this.lifespan = Math.random() * 100 + 50;
            this.radius = Math.random() * 1.5 + 1;
            this.hue = hue;
        }

        update() {
            super.update();
            if (this.age > this.lifespan) {
                this.dead = true;
            }
        }
        
        display() {
            const alpha = 1.0 - (this.age / this.lifespan);
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${alpha})`;
            ctx.fill();
        }
    }


    // FILE: Void.js
    // DESCRIPTION: Defines the Phantoms, the antagonists of light. They consume the web.
    //--------------------------------------------------------------------------------------------------
    class Phantom extends Particle {
        constructor() {
            super(Math.random() * canvas.width, Math.random() * canvas.height);
            this.maxSpeed = 0.5;
            this.maxForce = 0.01;
            this.radius = 100; // Radius of consumption
        }

        // Phantoms don't hunt weavers; they are drawn to the *density* of the web.
        // This is computationally intensive, a sign of its importance. It is the core
        // of the antagonistic force in this universe.
        seekWebDensity(weavers) {
            let centerOfMass = new Vector();
            let count = 0;

            weavers.forEach(weaver => {
                weaver.web.forEach(node => {
                    const dSq = Vector.distSq(this.pos, node.pos);
                    if (dSq < PHANTOM_SIGHT_RADIUS * PHANTOM_SIGHT_RADIUS) {
                        centerOfMass.add(node.pos);
                        count++;
                    }
                });
            });

            if (count > 0) {
                centerOfMass.div(count);
                let desired = Vector.sub(centerOfMass, this.pos);
                desired.normalize().mult(this.maxSpeed);
                let steer = Vector.sub(desired, this.vel);
                steer.limit(this.maxForce);
                this.applyForce(steer);
            }
        }
        
        // As a phantom moves, it "consumes" the light of the web, accelerating its decay.
        consume(weavers) {
            weavers.forEach(weaver => {
                weaver.web.forEach(node => {
                    const dSq = Vector.distSq(this.pos, node.pos);
                    if(dSq < this.radius * this.radius) {
                        node.lifespan -= 0.02; // Rapidly decay nearby nodes
                    }
                });
            });
        }

        update() {
            super.update();
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);
        }

        display() {
            // Phantoms are rendered as voids, absences of light.
            const gradient = ctx.createRadialGradient(this.pos.x, this.pos.y, 0, this.pos.x, this.pos.y, this.radius);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            // By using 'destination-out', we erase parts of the canvas, creating a true void.
            // This is a more advanced technique than just drawing black.
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }


    // FILE: Universe.js
    // DESCRIPTION: The main simulation logic that orchestrates all interactions.
    //--------------------------------------------------------------------------------------------------
    function init() {
        for (let i = 0; i < WEAVER_COUNT; i++) {
            weavers.push(new Weaver(i * (360 / WEAVER_COUNT)));
        }
        for (let i = 0; i < PHANTOM_COUNT; i++) {
            phantoms.push(new Phantom());
        }
    }

    function animate() {
        // We do not clear the canvas. Instead, we draw a semi-transparent black rectangle.
        // This creates the beautiful, ethereal trails and motion blur that are essential
        // to the aesthetic. It is the memory of the universe.
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'lighter';
        
        // --- The User as a Harmonic Resonator ---
        // The user does not pull. The user excites. Their presence makes the web sing,
        // vibrating with brighter light and giving birth to new Glimmer.
        const mouseVector = new Vector(MOUSE.x, MOUSE.y);
        weavers.forEach(weaver => {
            weaver.web.forEach(node => {
                const dSq = Vector.distSq(mouseVector, node.pos);
                if (dSq < MOUSE.radius * MOUSE.radius) {
                    node.brightness = Math.min(2.0, node.brightness + 0.1);
                    if (Math.random() < GLIMMER_SPAWN_CHANCE * 0.05) {
                        glimmers.push(new Glimmer(node.pos.x, node.pos.y, weaver.hue));
                    }
                }
            });
        });

        // --- Update and Display Weavers ---
        weavers.forEach(w => {
            let closestGlimmer = null;
            let minDistSq = Infinity;
            glimmers.forEach(g => {
                let dSq = Vector.distSq(w.pos, g.pos);
                if(dSq < minDistSq) {
                    minDistSq = dSq;
                    closestGlimmer = g;
                }
            });

            if (closestGlimmer && minDistSq < 200*200) {
                 w.seek(closestGlimmer);
                 if(minDistSq < 10*10) {
                    closestGlimmer.dead = true; // Consume glimmer
                 }
            } else {
                w.wander();
            }

            w.update();
            w.display();

            // Randomly spawn new Glimmer along the web
            if (w.web.length > 1 && Math.random() < GLIMMER_SPAWN_CHANCE) {
                const randomNode = w.web[Math.floor(Math.random() * w.web.length)];
                glimmers.push(new Glimmer(randomNode.pos.x, randomNode.pos.y, w.hue));
            }
        });

        // --- Update and Display Phantoms ---
        phantoms.forEach(p => {
            p.seekWebDensity(weavers);
            p.update();
            p.consume(weavers);
            p.display();
        });

        // --- Update and Display Glimmers ---
        for (let i = glimmers.length - 1; i >= 0; i--) {
            glimmers[i].update();
            glimmers[i].display();
            if (glimmers[i].isDead()) {
                glimmers.splice(i, 1);
            }
        }
        
        frame++;
        requestAnimationFrame(animate);
    }
    
    // --- Event Listeners: The Observer's Interface ---
    window.addEventListener('mousemove', e => { MOUSE.x = e.clientX; MOUSE.y = e.clientY; });
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // --- Let there be Light ---
    init();
    animate();
    </script>
</body>
</html>
