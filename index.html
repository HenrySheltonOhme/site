<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genesis of Emergent Symmetry</title>
    <style>
        /* PHILOSOPHICAL PRINCIPLE: The canvas begins in perfect void - the state of maximum entropy */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }
        
        canvas {
            display: block;
            cursor: none;
        }

        /* PHILOSOPHICAL PRINCIPLE: The interface must be invisible, allowing direct communion with the artifact */
        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-family: monospace;
            font-size: 12px;
            user-select: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="genesisCanvas"></canvas>
    <div class="status" id="statusDisplay">ENTROPY STATE: PRIMORDIAL CHAOS</div>

    <script>
        // ARTISTIC INTENT: I am creating a universe that begins in pure randomness
        // and gradually self-organizes into complex patterns through simple rules
        // This mirrors the cosmic principle of order emerging from chaos
        
        const canvas = document.getElementById('genesisCanvas');
        const ctx = canvas.getContext('2d');
        const statusDisplay = document.getElementById('statusDisplay');
        
        // PHILOSOPHICAL PRINCIPLE: The canvas dimensions represent the fundamental boundaries of this digital universe
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // CONCEPTUAL FRAMEWORK: I am implementing a novel cellular automata system
        // that operates on principles of quantum-inspired superposition and collapse
        // Each cell exists in multiple states simultaneously until observed/calculated
        
        const CELL_SIZE = 4;
        const COLS = Math.floor(canvas.width / CELL_SIZE);
        const ROWS = Math.floor(canvas.height / CELL_SIZE);
        
        // ARTISTIC INTENT: The grid represents the fundamental fabric of this digital reality
        // Each cell has properties that exist in quantum-like superposition
        let quantumGrid = [];
        
        // CONCEPTUAL FRAMEWORK: I am creating 7 fundamental "quantum properties"
        // that interact in non-classical ways to generate emergent complexity
        const PROPERTIES = ['spin', 'phase', 'resonance', 'entropy', 'coherence', 'symmetry', 'tension'];
        
        // PHILOSOPHICAL PRINCIPLE: Initial state is maximum entropy - perfect chaos
        // Each property exists in random superposition
        function initializeQuantumGrid() {
            quantumGrid = [];
            for (let y = 0; y < ROWS; y++) {
                quantumGrid[y] = [];
                for (let x = 0; x < COLS; x++) {
                    quantumGrid[y][x] = {
                        spin: Math.random() * 2 - 1,        // Angular momentum tendency
                        phase: Math.random() * Math.PI * 2, // Wave phase alignment  
                        resonance: Math.random(),           // Vibration frequency
                        entropy: 1.0,                       // Disorder level (starts maximum)
                        coherence: 0,                       // Order level (starts minimum)
                        symmetry: 0,                        // Pattern formation tendency
                        tension: Math.random(),             // Energy potential
                        collapsed: false,                   // Whether state is determined
                        age: 0,                             // Temporal existence
                        influence: 0                        // Effect on neighbors
                    };
                }
            }
        }
        
        // ARTISTIC INTENT: The color system maps abstract quantum properties to visual perception
        // This creates a synesthetic experience where mathematical states become aesthetic phenomena
        function quantumStateToColor(cell) {
            // CONCEPTUAL FRAMEWORK: RGB channels map to different quantum properties
            // creating a direct translation between mathematical reality and sensory experience
            
            const r = Math.abs(Math.sin(cell.phase * cell.resonance)) * 255;
            const g = Math.abs(Math.cos(cell.spin * cell.age * 0.1)) * 255;
            const b = (1 - cell.entropy) * 255;
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // PHILOSOPHICAL PRINCIPLE: The update rules are the fundamental laws of this universe
        // They are simple, local interactions that give rise to global complexity
        function updateQuantumGrid() {
            const newGrid = [];
            let totalCoherence = 0;
            let totalSymmetry = 0;
            
            for (let y = 0; y < ROWS; y++) {
                newGrid[y] = [];
                for (let x = 0; x < COLS; x++) {
                    const cell = quantumGrid[y][x];
                    const neighbors = getQuantumNeighbors(x, y);
                    
                    // ARTISTIC INTENT: These equations represent the "laws of physics"
                    // for this digital universe - they balance determinism and randomness
                    
                    // Calculate influence from neighbors (quantum entanglement simulation)
                    let spinInfluence = 0;
                    let phaseResonance = 0;
                    let neighborCoherence = 0;
                    
                    neighbors.forEach(neighbor => {
                        spinInfluence += neighbor.spin * neighbor.coherence;
                        phaseResonance += Math.sin(neighbor.phase) * neighbor.resonance;
                        neighborCoherence += neighbor.coherence;
                    });
                    
                    const avgCoherence = neighborCoherence / neighbors.length;
                    
                    // CONCEPTUAL FRAMEWORK: The state evolution follows non-linear dynamics
                    // creating the conditions for emergent self-organization
                    const newSpin = (cell.spin + spinInfluence * 0.1) * 0.95;
                    const newPhase = (cell.phase + phaseResonance * 0.05) % (Math.PI * 2);
                    const newResonance = Math.max(0, Math.min(1, 
                        cell.resonance + (avgCoherence - cell.resonance) * 0.1
                    ));
                    
                    // PHILOSOPHICAL PRINCIPLE: Entropy decreases as coherence increases
                    // representing the universe's tendency toward order through interaction
                    const newCoherence = Math.max(0, Math.min(1, 
                        cell.coherence + (avgCoherence - cell.coherence) * 0.05
                    ));
                    const newEntropy = 1 - newCoherence;
                    
                    // ARTISTIC INTENT: Symmetry emerges from phase alignment and resonance matching
                    let phaseAlignment = 0;
                    neighbors.forEach(neighbor => {
                        const phaseDiff = Math.abs(cell.phase - neighbor.phase);
                        phaseAlignment += 1 - (phaseDiff / (Math.PI * 2));
                    });
                    
                    const newSymmetry = Math.max(0, Math.min(1,
                        cell.symmetry + (phaseAlignment / neighbors.length - 0.5) * 0.1
                    ));
                    
                    // CONCEPTUAL FRAMEWORK: Tension represents potential energy
                    // that can be released to create dynamic patterns
                    const coherenceDifference = Math.abs(cell.coherence - avgCoherence);
                    const newTension = Math.max(0, Math.min(1,
                        cell.tension * 0.9 + coherenceDifference * 0.1
                    ));
                    
                    newGrid[y][x] = {
                        spin: newSpin,
                        phase: newPhase,
                        resonance: newResonance,
                        entropy: newEntropy,
                        coherence: newCoherence,
                        symmetry: newSymmetry,
                        tension: newTension,
                        collapsed: cell.coherence > 0.8, // High coherence collapses superposition
                        age: cell.age + 1,
                        influence: Math.abs(spinInfluence) + Math.abs(phaseResonance)
                    };
                    
                    totalCoherence += newCoherence;
                    totalSymmetry += newSymmetry;
                }
            }
            
            quantumGrid = newGrid;
            
            // Update status display with emergent properties
            const avgCoherence = totalCoherence / (ROWS * COLS);
            const avgSymmetry = totalSymmetry / (ROWS * COLS);
            
            if (avgCoherence < 0.2) {
                statusDisplay.textContent = `ENTROPY STATE: PRIMORDIAL CHAOS | SYMMETRY: ${avgSymmetry.toFixed(3)}`;
            } else if (avgCoherence < 0.5) {
                statusDisplay.textContent = `ENTROPY STATE: EMERGENT PATTERNS | SYMMETRY: ${avgSymmetry.toFixed(3)}`;
            } else if (avgCoherence < 0.8) {
                statusDisplay.textContent = `ENTROPY STATE: SELF-ORGANIZATION | SYMMETRY: ${avgSymmetry.toFixed(3)}`;
            } else {
                statusDisplay.textContent = `ENTROPY STATE: CRYSTALLINE ORDER | SYMMETRY: ${avgSymmetry.toFixed(3)}`;
            }
        }
        
        // ARTISTIC INTENT: The neighbor function creates the connectivity topology
        // Using a Moore neighborhood (8 surrounding cells) for rich interaction
        function getQuantumNeighbors(x, y) {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = (x + dx + COLS) % COLS;
                    const ny = (y + dy + ROWS) % ROWS;
                    
                    neighbors.push(quantumGrid[ny][nx]);
                }
            }
            return neighbors;
        }
        
        // CONCEPTUAL FRAMEWORK: The rendering process translates quantum states
        // into visual phenomena, creating a bridge between mathematics and perception
        function renderQuantumGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = quantumGrid[y][x];
                    const color = quantumStateToColor(cell);
                    
                    // ARTISTIC INTENT: Visual properties change based on quantum state
                    // creating a rich, dynamic visual landscape
                    ctx.fillStyle = color;
                    
                    // PHILOSOPHICAL PRINCIPLE: The size and shape of each element
                    // reflects its quantum properties and relationships
                    const sizeMod = cell.coherence * CELL_SIZE;
                    const rotation = cell.spin * Math.PI;
                    
                    ctx.save();
                    ctx.translate(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2);
                    ctx.rotate(rotation);
                    
                    // CONCEPTUAL FRAMEWORK: Different rendering modes based on coherence level
                    // representing different phases of organization
                    if (cell.coherence < 0.3) {
                        // Chaos phase: simple points
                        ctx.fillRect(-sizeMod/2, -sizeMod/2, sizeMod, sizeMod);
                    } else if (cell.coherence < 0.6) {
                        // Organization phase: emerging shapes
                        ctx.beginPath();
                        ctx.arc(0, 0, sizeMod/2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Order phase: complex geometric forms
                        ctx.beginPath();
                        const sides = 3 + Math.floor(cell.symmetry * 5);
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI / sides) + cell.phase;
                            const radius = sizeMod/2;
                            const px = Math.cos(angle) * radius;
                            const py = Math.sin(angle) * radius;
                            if (i === 0) {
                                ctx.moveTo(px, py);
                            } else {
                                ctx.lineTo(px, py);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        // ARTISTIC INTENT: User interaction introduces perturbations to the system
        // allowing humans to participate in the cosmic dance of order and chaos
        let mouseX = -1000;
        let mouseY = -1000;
        let mouseStrength = 0;
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseStrength = 1.0;
        });
        
        canvas.addEventListener('click', (e) => {
            // PHILOSOPHICAL PRINCIPLE: A click creates a "quantum fluctuation"
            // that can trigger phase transitions in the system
            const gridX = Math.floor(e.clientX / CELL_SIZE);
            const gridY = Math.floor(e.clientY / CELL_SIZE);
            
            if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                // Create a coherence singularity
                for (let dy = -3; dy <= 3; dy++) {
                    for (let dx = -3; dx <= 3; dx++) {
                        const nx = (gridX + dx + COLS) % COLS;
                        const ny = (gridY + dy + ROWS) % ROWS;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const influence = Math.max(0, 1 - distance/4);
                        
                        quantumGrid[ny][nx].coherence += influence * 0.5;
                        quantumGrid[ny][nx].entropy = 1 - quantumGrid[ny][nx].coherence;
                        quantumGrid[ny][nx].phase += influence * Math.PI;
                    }
                }
            }
        });
        
        // CONCEPTUAL FRAMEWORK: The main animation loop represents the flow of time
        // in this digital universe, driving the eternal process of creation and evolution
        function animate() {
            // Apply mouse influence as external perturbation
            if (mouseStrength > 0) {
                const gridX = Math.floor(mouseX / CELL_SIZE);
                const gridY = Math.floor(mouseY / CELL_SIZE);
                
                if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                    // Create a zone of influence around mouse
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            const nx = (gridX + dx + COLS) % COLS;
                            const ny = (gridY + dy + ROWS) % ROWS;
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            const influence = Math.max(0, (1 - distance/3)) * mouseStrength;
                            
                            quantumGrid[ny][nx].spin += (Math.random() - 0.5) * influence * 0.1;
                            quantumGrid[ny][nx].phase += influence * 0.1;
                            quantumGrid[ny][nx].tension += influence * 0.05;
                        }
                    }
                }
                
                mouseStrength *= 0.9; // Gradually decay mouse influence
            }
            
            updateQuantumGrid();
            renderQuantumGrid();
            requestAnimationFrame(animate);
        }
        
        // PHILOSOPHICAL PRINCIPLE: The universe begins with a single function call
        // representing the initial moment of creation from nothingness
        initializeQuantumGrid();
        animate();
        
        // ARTISTIC INTENT: Respond to window resizing by recreating the universe
        // This represents the concept of multiple possible realities
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initializeQuantumGrid();
        });
        
        // FINAL ARTISTIC STATEMENT: This artifact explores the fundamental cosmic principle
        // that complex order can emerge from simple rules applied to initial chaos.
        // The human observer witnesses the eternal dance between entropy and organization,
        // between randomness and pattern, between chaos and symmetry.
        // Through minimal interaction, they participate in this cosmic process,
        // experiencing the beautiful, emergent mathematics that underpin all existence.
    </script>
</body>
</html>
