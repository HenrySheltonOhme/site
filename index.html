<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squad Pluto</title>
    <style>
        /*
        // DECREE V5.0: THE FINAL AESTHETIC //
        // The space is a living mind. The background is a deep void.
        // The standard cursor is restored for a responsive, lag-free experience.
        */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(900px 600px at 50% 45%, rgba(60, 70, 120, 0.18), rgba(0, 0, 0, 0)), #020205; /* Subtle vignette over deep navy */
            height: 100%;
            width: 100%;
            cursor: default; /* Restored the default cursor */
        }

        /* The canvas holds the subconscious and the hidden order. It is the foundation. */
        #mind-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /* The central identity. A modern, clean, and unmoving point of focus. */
        .title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none; /* It does not interfere with interaction */
            text-align: center;
        }

        .title-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 2.8em;
            font-weight: 200; /* Thin and elegant */
            background-image: linear-gradient(180deg, rgba(235, 235, 255, 0.92), rgba(170, 185, 255, 0.65));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: none;
            letter-spacing: 2px;
            user-select: none;
        }
        .title-text a { color: inherit; text-decoration: none; pointer-events: all; cursor: pointer; position: relative; transition: color 0.2s ease; }
        .title-text a:hover { color: rgba(240, 245, 255, 0.95); }
        .title-text a::after { content: ""; position: absolute; left: 50%; bottom: -6px; width: 0; height: 1px; background: linear-gradient(90deg, rgba(180,210,255,0), rgba(180,210,255,0.6), rgba(180,210,255,0)); transition: width 180ms ease, left 180ms ease; }
        .title-text a:hover::after { width: 100%; left: 0; }

        .subtitle-text {
            margin-top: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 0.95em;
            font-weight: 300;
            color: rgba(210, 220, 255, 0.65);
            text-shadow: 0 0 18px rgba(160, 175, 235, 0.18);
            letter-spacing: 3px;
            user-select: none;
        }

        /* This container will hold the conscious thoughts (the projects). */
        #thoughts-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none; /* Container itself is not interactive */
        }

        /* Styling for each individual thought. They are ethereal but tangible. */
        .thought-node {
            position: absolute;
            color: rgba(200, 225, 255, 0.8);
            background-color: rgba(10, 10, 20, 0.3);
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid rgba(170, 200, 255, 0.16);
            font-size: 14px;
            text-decoration: none;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            pointer-events: all; /* The thoughts themselves ARE interactive */
            transition: transform 0.2s ease-out, background-color 0.3s, color 0.3s, border-color 0.3s, box-shadow 0.3s;
            will-change: transform; /* Performance hint for the browser */
            -webkit-tap-highlight-color: transparent;
        }

        .thought-node:hover {
            color: rgba(255, 255, 255, 1);
            background-color: rgba(50, 50, 80, 0.5);
            border-color: rgba(200, 220, 255, 0.5);
            box-shadow: 0 0 20px rgba(150, 180, 255, 0.2);
            transform: scale(1.1); /* Grow on hover for a satisfying effect */
        }
        /* Active project subtle green glow */
        .thought-node.active {
            border-color: rgba(100, 255, 190, 0.45);
            box-shadow: 0 0 18px rgba(100, 255, 190, 0.18), inset 0 0 8px rgba(100, 255, 190, 0.08);
        }
        .thought-node.active:hover {
            border-color: rgba(120, 255, 200, 0.7);
            box-shadow: 0 0 22px rgba(100, 255, 190, 0.28), inset 0 0 10px rgba(100, 255, 190, 0.12);
        }
        .thought-node:focus-visible {
            outline: 2px solid rgba(200, 220, 255, 0.75);
            outline-offset: 2px;
            box-shadow: 0 0 24px rgba(150, 180, 255, 0.3);
        }
        @media (prefers-reduced-motion: reduce) {
            .thought-node { transition: none; }
        }
    </style>
</head>
<body>
    <canvas id="mind-canvas"></canvas>
    <div class="title-container">
        <h1 class="title-text"><a href="./squadpluto.html" style="text-decoration:none; color: inherit; pointer-events: all;">Squad Pluto</a></h1>
        <div class="subtitle-text">AM | DS | HS | GB | DX</div>
    </div>
    <div id="thoughts-container"></div>
    
    <script>
    //=======================================================================================//
    //                                                                                       //
    //                  THE LIVING MIND - FINAL VERSION (FULLY DYNAMIC)                      //
    //                                                                                       //
    //=======================================================================================//
    //
    // This is the definitive script, incorporating all refinements from our dialogue.
    // The background is now a fully dynamic, wandering neural network that interacts with
    // the user. All project "thoughts" are present from the start and now link to their
    // respective URLs.
    //
    //---------------------------------------------------------------------------------------//

    'use strict';

    // --- Core Setup ---
    const canvas = document.getElementById('mind-canvas');
    const ctx = canvas.getContext('2d');
    const thoughtsContainer = document.getElementById('thoughts-container');
    const titleContainer = document.querySelector('.title-container');
    let titleBounds = { cx: 0, cy: 0, halfW: 0, halfH: 0 };
    function updateTitleBounds() {
        if (!titleContainer) return;
        const rect = titleContainer.getBoundingClientRect();
        titleBounds = {
            cx: rect.left + rect.width / 2,
            cy: rect.top + rect.height / 2,
            halfW: rect.width / 2 + 60, // reduced buffer; just enough to avoid overlap
            halfH: rect.height / 2 + 60
        };
    }

    let width = window.innerWidth;
    let height = window.innerHeight;
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resizeCanvas() {
        const cssW = Math.floor(window.innerWidth);
        const cssH = Math.floor(window.innerHeight);
        width = cssW;
        height = cssH;
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    const mouse = {
        x: width / 2,
        y: height / 2,
        radius: 150 // Radius of influence
    };

    // --- The Conscious Thoughts (Project Data with URLs) ---
    // This new structure holds both the name and the corresponding URL for each project.
    const projectData = [
        { name: "Customer Success Agents", url: "customer-success-agents.html" },
        { name: "ML/AIOps", url: "ml-aiops.html" },
        { name: "Ohme Enterprise Knowledge Center", url: "ohme-enterprise-knowledge-center.html" },
        { name: "Journey Computer Vision", url: "journey-computer-vision.html" },
        { name: "Energy Consumption Forecasting", url: "energy-consumption-forecasting.html" },
        { name: "Session Params Prediction", url: "session-params-prediction.html" },
        { name: "CX Agents Evaluation", url: "cx-agents-evaluation.html" },
        { name: "Sentinel", url: "sentinel.html" },
        { name: "CX Engine", url: "cx-engine.html" },
        { name: "Crowdflex", url: "crowdflex.html" },
        { name: "POCs", url: "pocs.html" }
    ];
    let thoughts = [];

    // --- The Subconscious (Neuron Simulation) ---
    const NEURON_COUNT = 200;
    const NEIGHBOR_RADIUS = 100;
    const neurons = [];

    // --- The Hidden Order (Deterministic Grid) ---
    const GRID_SPACING = 50;
    const GRID_REVEAL_RADIUS = 250;


    // --- Math Libraries ---
    class Vector {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        add(v) { this.x += v.x; this.y += v.y; return this; }
        sub(v) { this.x -= v.x; this.y -= v.y; return this; }
        mult(s) { this.x *= s; this.y *= s; return this; }
        magSq() { return this.x * this.x + this.y * this.y; }
        mag() { return Math.sqrt(this.magSq()); }
        normalize() { const m = this.mag(); if (m > 0) { this.x /= m; this.y /= m; } return this; }
        static distSq(v1, v2) { const dx = v1.x - v2.x; const dy = v1.y - v2.y; return dx * dx + dy * dy; }
    }

    // Perlin noise function for organic movement
    function noise(x, y = 0, z = 0) {
        const p = new Array(512);
        const permutation = [ 151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];
        for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i];
        
        const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
        const lerp = (t, a, b) => a + t * (b - a);
        const grad = (hash, x, y, z) => {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };

        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        const u = fade(x);
        const v = fade(y);
        const w = fade(z);
        const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z;
        const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;

        return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x-1, y, z)),
                               lerp(u, grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z))),
                       lerp(v, lerp(u, grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1)),
                               lerp(u, grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1))));
    }


    // --- Layer 1: The Subconscious Neuron ---
    // Represents the biological foundation. They now wander freely, creating a dynamic, living web.
    class Neuron {
        constructor(x, y) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(Math.random() - 0.5, Math.random() - 0.5);
            this.acc = new Vector();
            this.radius = Math.random() * 2 + 1;
            this.damping = 0.98; // Slightly more friction for a smoother flow
            this.maxSpeed = 2; // <-- INCREASED THIS VALUE
            this.color = `rgba(180, 200, 255, ${Math.random() * 0.3 + 0.2})`; 
            this.noiseOffset = Math.random() * 1000; // Unique offset for Perlin noise
        }
    
        applyForce(force) {
            this.acc.add(force);
        }
    
        // This method now orchestrates all movement behaviors
        behaviors() {
            this.wander(); // The new primary driving force
            this.repelMouse(); // The interactive force
        }
    
        // Organic wandering behavior using Perlin Noise
        wander() {
            // We use Perlin noise to generate a smoothly changing angle, creating a "flow field" effect.
            // This is what makes the neurons "twirl" and "move around" organically.
            const time = Date.now() * 0.0001;
            const angle = (noise(this.pos.x * 0.01, this.pos.y * 0.01, time + this.noiseOffset)) * Math.PI * 4;
            const wanderForce = new Vector(Math.cos(angle), Math.sin(angle));
            wanderForce.mult(0.1); // <-- INCREASED THIS VALUE
            this.applyForce(wanderForce);
        }
    
        repelMouse() {
            const mouseDistSq = Vector.distSq(this.pos, mouse);
            if (mouseDistSq < mouse.radius * mouse.radius) {
                let mouseForce = new Vector(this.pos.x - mouse.x, this.pos.y - mouse.y);
                const distance = Math.sqrt(mouseDistSq);
                // The force is stronger the closer the mouse is
                const forceMagnitude = (mouse.radius - distance) * 0.01;
                mouseForce.normalize().mult(forceMagnitude);
                this.applyForce(mouseForce);
            }
        }
    
        update() {
            this.vel.add(this.acc);
            this.vel.mult(this.damping);
            
            // Limit speed to prevent them from flying too fast
            if (this.vel.magSq() > this.maxSpeed * this.maxSpeed) {
                this.vel.normalize().mult(this.maxSpeed);
            }
    
            this.pos.add(this.vel);
            this.acc.mult(0); // Reset acceleration each frame
            this.checkBounds(); // Keep neurons on the screen
        }
        
        // Screen wrapping behavior
        checkBounds() {
            if (this.pos.x < -10) this.pos.x = width + 10;
            if (this.pos.x > width + 10) this.pos.x = -10;
            if (this.pos.y < -10) this.pos.y = height + 10;
            if (this.pos.y > height + 10) this.pos.y = -10;
        }
    
        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }
    }


    // --- Layer 2: The Conscious Thought Node ---
    // Represents the interactive, high-level ideas. They are HTML elements driven by a physics simulation.
    class ThoughtNode {
        constructor(element) {
            this.el = element;
            this.pos = new Vector(Math.random() * width, Math.random() * height);
            this.vel = new Vector(Math.random() - 0.5, Math.random() - 0.5);
            this.acc = new Vector();
            this.maxSpeed = 0.5;
            this.maxForce = 0.02;
            this.damping = 0.98;
        }

        applyForce(force) {
            this.acc.add(force);
        }

        // The physics that governs the movement of thoughts
        behaviors(allThoughts) {
            // 1. Repulsion from other thoughts
            for (const other of allThoughts) {
                if (other === this) continue;
                const distSq = Vector.distSq(this.pos, other.pos);
                if (distSq < 200 * 200) {
                    let force = new Vector(this.pos.x - other.pos.x, this.pos.y - other.pos.y);
                    force.normalize().mult(0.1 / (distSq * 0.0001 + 1)); // Stronger when closer
                    this.applyForce(force);
                }
            }

            // 2. Attraction to the center of the screen (keeps them from flying away)
            let centerForce = new Vector(width / 2 - this.pos.x, height / 2 - this.pos.y);
            centerForce.normalize().mult(0.01);
            this.applyForce(centerForce);

            // 3. Repulsion from the mouse cursor (user interaction)
            const mouseDistSq = Vector.distSq(this.pos, mouse);
            if (mouseDistSq < mouse.radius * mouse.radius) {
                let mouseForce = new Vector(this.pos.x - mouse.x, this.pos.y - mouse.y);
                mouseForce.normalize().mult(0.5);
                this.applyForce(mouseForce);
            }
        // 4. Repel from centered title to prevent overlap
        const dxTitle = this.pos.x - titleBounds.cx;
        const dyTitle = this.pos.y - titleBounds.cy;
        if (Math.abs(dxTitle) < titleBounds.halfW && Math.abs(dyTitle) < titleBounds.halfH) {
            let titleForce = new Vector(dxTitle, dyTitle);
            titleForce.normalize().mult(0.6);
            this.applyForce(titleForce);
        }
        }

        update() {
            this.vel.add(this.acc);
            this.vel.mult(this.damping);
            if (this.vel.magSq() > this.maxSpeed * this.maxSpeed) {
                this.vel.normalize().mult(this.maxSpeed);
            }
            this.pos.add(this.vel);
            this.acc.mult(0); // Reset acceleration
        }

        render() {
        // Keep within viewport bounds and update CSS position
        const halfW = this.el.offsetWidth / 2;
        const halfH = this.el.offsetHeight / 2;
        const pad = 12;
        const minX = halfW + pad;
        const maxX = width - halfW - pad;
        const minY = halfH + pad;
        const maxY = height - halfH - pad;
        if (this.pos.x < minX) { this.pos.x = minX; this.vel.x *= -0.3; }
        if (this.pos.x > maxX) { this.pos.x = maxX; this.vel.x *= -0.3; }
        if (this.pos.y < minY) { this.pos.y = minY; this.vel.y *= -0.3; }
        if (this.pos.y > maxY) { this.pos.y = maxY; this.vel.y *= -0.3; }
        this.el.style.transform = `translate(${this.pos.x - halfW}px, ${this.pos.y - halfH}px)`;
        }
    }


    // --- Initialization Function ---
    // Sets up the entire scene.
    function init() {
        // Re-populate the subconscious neuron web
        neurons.length = 0; // Clear existing neurons on resize
        for (let i = 0; i < NEURON_COUNT; i++) {
            neurons.push(new Neuron(Math.random() * width, Math.random() * height));
        }

        // Remove existing HTML elements and thoughts array
        thoughtsContainer.innerHTML = '';
        thoughts.length = 0;

        // Instantly create all conscious thoughts
        for (const project of projectData) {
            const el = document.createElement('a');
            el.href = project.url;
            if (/^https?:\/\//i.test(project.url)) {
                el.target = "_blank";
                el.rel = "noopener noreferrer";
            } else {
                el.target = "_self";
            }
            el.classList.add('thought-node');
            // Mark active projects with subtle green glow
            const active = [
                'Sentinel',
                'Session Params Prediction',
                'POCs',
                'Crowdflex',
                'Journey Computer Vision'
            ];
            if (active.includes(project.name)) {
                el.classList.add('active');
            }
            el.textContent = project.name;
            thoughtsContainer.appendChild(el);
            thoughts.push(new ThoughtNode(el));
        }
    }


    // --- The Main Animation Loop ---
    // This function is the heartbeat of the visualization.
    function animate() {
        // Update title bounds to keep exclusion accurate (handles font/resize/layout changes)
        updateTitleBounds();
        // Clear the canvas for redrawing
        ctx.clearRect(0, 0, width, height);

        // --- Layer 2: The Hidden Order (The Twang) ---
        // This is drawn first, so it's in the deep background.
        // It's a grid that becomes more visible near the mouse, revealing the deterministic structure.
        for (let x = 0; x < width; x += GRID_SPACING) {
            for (let y = 0; y < height; y += GRID_SPACING) {
                const distSq = (x - mouse.x) * (x - mouse.x) + (y - mouse.y) * (y - mouse.y);
                if (distSq < GRID_REVEAL_RADIUS * GRID_REVEAL_RADIUS) {
                    const opacity = 1 - (distSq / (GRID_REVEAL_RADIUS * GRID_REVEAL_RADIUS));
                    ctx.fillStyle = `rgba(120, 140, 210, ${opacity * 0.18})`;
                    ctx.fillRect(x - 0.5, y - 0.5, 1, 1);
                }
            }
        }
        
        // --- Layer 1: The Subconscious (The Brain) ---
        // Update neurons and draw dynamic connections
        for (let i = 0; i < neurons.length; i++) {
            const ni = neurons[i];
            ni.behaviors(); // Apply forces first
            ni.update();
            ni.draw(ctx);

            // Check for connections to other neurons and draw them
            for (let j = i + 1; j < neurons.length; j++) {
                const nj = neurons[j];
                const distSq = Vector.distSq(ni.pos, nj.pos);

                // If they are close enough, draw a connection
                if (distSq < NEIGHBOR_RADIUS * NEIGHBOR_RADIUS) {
                    // The closer they are, the more opaque the connection
                    const opacity = 1 - (distSq / (NEIGHBOR_RADIUS * NEIGHBOR_RADIUS));
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.strokeStyle = `rgba(135, 165, 255, ${opacity * 0.2})`;
                    ctx.lineWidth = 0.7;
                    ctx.beginPath();
                    ctx.moveTo(ni.pos.x, ni.pos.y);
                    ctx.lineTo(nj.pos.x, nj.pos.y);
                    ctx.stroke();
                }
            }
        }

        // --- Layer 3: The Conscious Thoughts ---
        // Update the physics and render the position of the HTML elements.
        for (const thought of thoughts) {
            thought.behaviors(thoughts);
            thought.update();
            thought.render();
        }

        // Keep the loop going
        requestAnimationFrame(animate);
    }


    // --- Event Listeners ---
    window.addEventListener('resize', () => {
        resizeCanvas();
        // Re-initialize on resize to recreate all elements for the new size
        updateTitleBounds();
        init();
    }, { passive: true });

    window.addEventListener('pointermove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }, { passive: true });

    // --- Let there be thought ---
    resizeCanvas();
    updateTitleBounds();
    init();
    animate();

    </script>
</body>
</html>
